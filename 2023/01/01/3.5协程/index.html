<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 8.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"aurora-lsk.asia","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="协程理论 【一】基于单线程来实现并�? �?】并发的本质   本节的主题是基于单线程来实现并发    即只用一个主线程（很明显可利用的cpu只有一个）情况下实现并�? 为此我们需要先回顾下并发的本质�?       切换+保存状�?      CPU正在运行一个任�?    会在两种情况下切走去执行其他的任务（切换由操作系统强制控制） 一种情况是该任务发生了阻塞 另外一种情况是该任务计算的时间过长">
<meta property="og:type" content="article">
<meta property="og:title" content="3.5Э��">
<meta property="og:url" content="https://aurora-lsk.asia/2023/01/01/3.5%E5%8D%8F%E7%A8%8B/index.html">
<meta property="og:site_name" content="坤博客">
<meta property="og:description" content="协程理论 【一】基于单线程来实现并�? �?】并发的本质   本节的主题是基于单线程来实现并发    即只用一个主线程（很明显可利用的cpu只有一个）情况下实现并�? 为此我们需要先回顾下并发的本质�?       切换+保存状�?      CPU正在运行一个任�?    会在两种情况下切走去执行其他的任务（切换由操作系统强制控制） 一种情况是该任务发生了阻塞 另外一种情况是该任务计算的时间过长">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://zhaochunze.dream521.site/2322215-20230625082605320-1726976824.png">
<meta property="article:published_time" content="2022-12-31T16:00:00.000Z">
<meta property="article:modified_time" content="2025-10-11T09:47:38.634Z">
<meta property="article:author" content="坤">
<meta property="article:tag" content="Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://zhaochunze.dream521.site/2322215-20230625082605320-1726976824.png">

<link rel="canonical" href="https://aurora-lsk.asia/2023/01/01/3.5%E5%8D%8F%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>3.5Э�� | 坤博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">坤博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aurora-lsk.asia/2023/01/01/3.5%E5%8D%8F%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="坤">
      <meta itemprop="description" content="选择有时候比努力更重要，但是你不努力，选择就只是空谈">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="坤博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          3.5Э��
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="2023-01-01T00:00:00+08:00">2023-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-10-11 17:47:38" itemprop="dateModified" datetime="2025-10-11T17:47:38+08:00">2025-10-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Blog/" itemprop="url" rel="index"><span itemprop="name">Blog</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1>协程理论</h1>
<h1>【一】基于单线程来实现并�?</h1>
<h2 id="�-】并发的本质">�?】并发的本质</h2>
<ul>
<li>
<p>本节的主题是基于单线程来实现并发</p>
</li>
<li>
<ul>
<li>即只用一个主线程（很明显可利用的cpu只有一个）情况下实现并�?</li>
<li>为此我们需要先回顾下并发的本质�?</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li>切换+保存状�?</li>
</ul>
</li>
</ul>
</li>
<li>
<p>CPU正在运行一个任�?</p>
</li>
<li>
<ul>
<li>会在两种情况下切走去执行其他的任务（切换由操作系统强制控制）</li>
<li>一种情况是该任务发生了阻塞</li>
<li>另外一种情况是该任务计算的时间过长或有一个优先级更高的程序替代了它�?</li>
</ul>
</li>
</ul>
<p><img src="http://zhaochunze.dream521.site/2322215-20230625082605320-1726976824.png" alt="img"></p>
<p>ps�?</p>
<p>在介绍进程理论时，提及进程的三种执行状�?</p>
<p>而线程才是执行单位，所以也可以将上图理解为线程的三种状�?</p>
<h2 id="�-】yield关键�">�?】yield关键�?</h2>
<ul>
<li>
<p>其中第二种情况并不能提升效率</p>
</li>
<li>
<p>只是为了让cpu能够雨露均沾</p>
</li>
<li>
<p>实现看起来所有任务都被“同时”执行的效果</p>
</li>
<li>
<p>如果多个任务都是纯计算的</p>
</li>
<li>
<p>这种切换反而会降低效率�?</p>
</li>
<li>
<p>为此我们可以基于yield来验�?</p>
</li>
<li>
<ul>
<li>yield本身就是一种在单线程下可以保存任务运行状态的方法</li>
<li>我们来简单复习一下：</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">yield</span>可以保存状�?</span><br><span class="line">	<span class="keyword">yield</span>的状态保存与操作系统的保存线程状态很像，但是<span class="keyword">yield</span>是代码级别控制的，更轻量�?</span><br><span class="line"><span class="number">2</span> send可以把一个函数的结果传给另外一个函�?</span><br><span class="line">	以此实现单线程内程序之间的切�?</span><br></pre></td></tr></table></figure>
<ul>
<li>单纯地切换反而会降低运行效率</li>
</ul>
<h3 id="�-）串行执�">�?）串行执�?</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>):</span><br><span class="line">        i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>):</span><br><span class="line">        i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">func1()</span><br><span class="line">func2()</span><br><span class="line">stop = time.time()</span><br><span class="line"><span class="built_in">print</span>(stop - start)</span><br></pre></td></tr></table></figure>
<h3 id="�-）基于yield并发执行">�?）基于yield并发执行</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">    g = func1()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>):</span><br><span class="line">        i+<span class="number">1</span></span><br><span class="line">        <span class="built_in">next</span>(g)</span><br><span class="line"></span><br><span class="line">start=time.time()</span><br><span class="line">func2()</span><br><span class="line">stop=time.time()</span><br><span class="line"><span class="built_in">print</span>(stop-start)</span><br></pre></td></tr></table></figure>
<h2 id="�-】实现遇到IO自动切换">�?】实现遇到IO自动切换</h2>
<ul>
<li>
<p>第一种情况的切换�?</p>
</li>
<li>
<p>在任务一遇到IO情况�?</p>
</li>
<li>
<p>切到任务二去执行</p>
</li>
<li>
<p>这样就可以利用任务一阻塞的时间完成任务二的计�?</p>
</li>
<li>
<p>效率的提升就在于此�?</p>
</li>
<li>
<p>yield不能检测IO</p>
</li>
<li>
<ul>
<li>实现遇到IO自动切换</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;func1&#x27;</span>)</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">    g = func1()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        i + <span class="number">1</span></span><br><span class="line">        <span class="built_in">next</span>(g)</span><br><span class="line">        time.sleep(<span class="number">3</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;func2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">func2()</span><br><span class="line">stop = time.time()</span><br><span class="line"><span class="built_in">print</span>(stop - start)</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>*<em>对于单线程下，我们不可避免程序中出现IO操作，但如果我们能在自己的程序中（即用户程序级别，而非操作系统级别）控制单线程下的多个任务能在一个任务遇到io阻塞时就切换到另外一个任务去计算，这样就保证了该线程能够最大限度地处于就绪态，即随时都可以被cpu执行的状态，相当于我们在用户程序级别将自己的IO操作最大限度地隐藏起来，从而可以迷惑操作系统，让其看到：该线程好像是一直在计算，IO比较少，从而更多的将cpu的执行权限分配给我们的线程�?</em></p>
</li>
<li>
<p>协程的本质就是在单线程下</p>
</li>
<li>
<ul>
<li>由用户自己控制一个任务遇到io阻塞了就切换另外一个任务去执行，以此来提升效率�?</li>
</ul>
</li>
<li>
<p>为了实现它，我们需要找寻一种可以同时满足以下条件的解决方案�?</p>
</li>
<li>
<ul>
<li>可以控制多个任务之间的切换，切换之前将任务的状态保存下来，以便重新运行时，可以基于暂停的位置继续执行�?</li>
<li>作为1的补充：可以检测IO操作，在遇到IO操作的情况下才发生切�?</li>
</ul>
</li>
</ul>
<h1>【二】协程介�?</h1>
<h2 id="�-】什么是协程">�?】什么是协程</h2>
<ul>
<li>
<p>是单线程下的并发，又称微线程，纤程。英文名Coroutine�?</p>
</li>
<li>
<p>一句话说明什么是线程�?</p>
</li>
<li>
<ul>
<li>*<em>协程是一种用户态的轻量级线程，即协程是由用户程序自己控制调度的�?</em></li>
</ul>
</li>
<li>
<p>需要强调的是：</p>
</li>
<li>
<ul>
<li>python的线程属于内核级别的，即由操作系统控制调度（如单线程遇到io或执行时间过长就会被迫交出cpu执行权限，切换其他线程运行）</li>
<li>单线程内开启协程，一旦遇到io，就会从应用程序级别（而非操作系统）控制切换，以此来提升效率（！！！非io操作的切换与效率无关�?</li>
</ul>
</li>
<li>
<p>对比操作系统控制线程的切换，用户在单线程内控制协程的切换</p>
</li>
</ul>
<h2 id="�-】优�">�?】优�?</h2>
<ul>
<li>协程的切换开销更小，属于程序级别的切换，操作系统完全感知不到，因而更加轻量级</li>
<li>单线程内就可以实现并发的效果，最大限度地利用cpu</li>
<li>应用程序级别速度要远远高于操作系统的切换</li>
</ul>
<h2 id="�-】缺�">�?】缺�?</h2>
<ul>
<li>协程的本质是单线程下，无法利用多核，可以是一个程序开启多个进程，每个进程内开启多个线程，每个线程内开启协�?</li>
<li>协程指的是单个线程，因而一旦协程出现阻塞，将会阻塞整个线程(多个任务一旦有一个阻塞没有切，整个线程都阻塞在原�?该线程内的其他的任务都不能执行了)</li>
</ul>
<h2 id="�-】总结">�?】总结</h2>
<ul>
<li>*<em>1.必须在只有一个单线程里实现并�?</em></li>
<li><strong>2.修改共享数据不需加锁</strong></li>
<li>*<em>3.用户程序里自己保存多个控制流的上下文�?</em></li>
<li><strong>4.附加：一个协程遇到IO操作自动切换到其它协程（如何实现检测IO，yield、greenlet都无法实现，就用到了gevent模块（select机制））</strong></li>
</ul>
<h1>【三】Greenlet</h1>
<ul>
<li>
<p>如果我们在单个线程内�?0个任�?</p>
</li>
<li>
<ul>
<li>要想实现在多个任务之间切�?</li>
<li>使用yield生成器的方式过于麻烦（需要先得到初始化一次的生成器，然后再调用send。。。非常麻�?</li>
<li>而使用greenlet模块可以非常简单地实现�?0个任务直接的切换</li>
</ul>
</li>
</ul>
<h2 id="�-】安�">�?】安�?</h2>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install greenlet</span><br></pre></td></tr></table></figure>
<h2 id="�-】使�">�?】使�?</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> greenlet <span class="keyword">import</span> greenlet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s eat 1&#x27;</span> % name)</span><br><span class="line">    g2.switch(<span class="string">&#x27;hope&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s eat 2&#x27;</span> % name)</span><br><span class="line">    g2.switch()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">play</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s play 1&#x27;</span> % name)</span><br><span class="line">    g1.switch()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s play 2&#x27;</span> % name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g1 = greenlet(eat)</span><br><span class="line">g2 = greenlet(play)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以在第一次switch时传入参数，以后都不需�?</span></span><br><span class="line">g1.switch(<span class="string">&#x27;dream&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># dream eat 1</span></span><br><span class="line"><span class="comment"># hope play 1</span></span><br><span class="line"><span class="comment"># dream eat 2</span></span><br><span class="line"><span class="comment"># hope play 2</span></span><br></pre></td></tr></table></figure>
<h2 id="�-】单纯切换降低效�">�?】单纯切换降低效�?</h2>
<ul>
<li>单纯的切换（在没有io的情况下或者没有重复开辟内存空间的操作），反而会降低程序的执行速度</li>
</ul>
<h3 id="�-）顺序执�">�?）顺序执�?</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 顺序执行</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    res = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000000</span>):</span><br><span class="line">        res += i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">    res = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000000</span>):</span><br><span class="line">        res *= i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">f1()</span><br><span class="line">f2()</span><br><span class="line">stop = time.time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;run time is %s&#x27;</span> % (stop - start))</span><br><span class="line"><span class="comment"># run time is 3.5635316371917725</span></span><br></pre></td></tr></table></figure>
<h3 id="�-）切换执�">�?）切换执�?</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> greenlet <span class="keyword">import</span> greenlet</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    res = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000000</span>):</span><br><span class="line">        res += i</span><br><span class="line">        g2.switch()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">    res = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000000</span>):</span><br><span class="line">        res *= i</span><br><span class="line">        g1.switch()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">g1 = greenlet(f1)</span><br><span class="line">g2 = greenlet(f2)</span><br><span class="line">g1.switch()</span><br><span class="line">stop = time.time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;run time is %s&#x27;</span> % (stop - start))</span><br><span class="line"><span class="comment"># run time is 27.30641794204712</span></span><br></pre></td></tr></table></figure>
<h2 id="�-】小�">�?】小�?</h2>
<ul>
<li>
<p>greenlet只是提供了一种比generator更加便捷的切换方�?</p>
</li>
<li>
<ul>
<li>当切到一个任务执行时如果遇到io</li>
<li>那就原地阻塞，仍然是没有解决遇到IO自动切换来提升效率的问题�?</li>
</ul>
</li>
<li>
<p>单线程里的这20个任务的代码通常会既有计算操作又有阻塞操�?</p>
</li>
<li>
<ul>
<li>我们完全可以在执行任�?时遇到阻�?</li>
<li>就利用阻塞的时间去执行任�?。。。�?</li>
<li>如此，才能提高效率，这就用到了Gevent模块�?</li>
</ul>
</li>
</ul>
<h1>【四】Gevent介绍</h1>
<h2 id="�-】介�">�?】介�?</h2>
<ul>
<li>Gevent 是一个第三方�?</li>
<li>可以轻松通过gevent实现并发同步或异步编�?</li>
<li>在gevent中用到的主要模式是Greenlet</li>
<li>它是以C扩展模块形式接入Python的轻量级协程�?</li>
<li>Greenlet全部运行在主程序操作系统进程的内部，但它们被协作式地调度�?</li>
</ul>
<h2 id="�-�-安装">�?�?<em>安装</em>*</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install gevent</span><br></pre></td></tr></table></figure>
<h2 id="�-】使�-2">�?】使�?</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(args)  <span class="comment"># (1, 2, 3)</span></span><br><span class="line">    <span class="built_in">print</span>(kwargs)  <span class="comment"># &#123;&#x27;x&#x27;: 4, &#x27;y&#x27;: 5&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;ok&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个协程对象g1，spawn括号内第一个参数是函数名，如eat，后面可以有多个参数，可以是位置实参或关键字实参，都是传给函数eat�?</span></span><br><span class="line">g1 = gevent.spawn(func, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, x=<span class="number">4</span>, y=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个协程对象g2</span></span><br><span class="line">g2 = gevent.spawn(func2)</span><br><span class="line"></span><br><span class="line">g1.join()  <span class="comment"># 等待g1结束</span></span><br><span class="line"></span><br><span class="line">g2.join()  <span class="comment"># 等待g2结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者上述两步合作一步：gevent.joinall([g1,g2])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拿到func1的返回�?</span></span><br><span class="line">result = g1.value</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="comment"># ok</span></span><br></pre></td></tr></table></figure>
<h2 id="�-�-遇到IO阻塞时会自动切换任务">�?�?<em>遇到IO阻塞时会自动切换任务</em>*</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s eat 1&#x27;</span> % name)</span><br><span class="line">    gevent.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s eat 2&#x27;</span> % name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">play</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s play 1&#x27;</span> % name)</span><br><span class="line">    gevent.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s play 2&#x27;</span> % name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g1 = gevent.spawn(eat, <span class="string">&#x27;dream&#x27;</span>)</span><br><span class="line">g2 = gevent.spawn(play, name=<span class="string">&#x27;hope&#x27;</span>)</span><br><span class="line">g1.join()</span><br><span class="line">g2.join()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者gevent.joinall([g1,g2])</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;�?)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># dream eat 1</span></span><br><span class="line"><span class="string"># hope play 1</span></span><br><span class="line"><span class="string"># hope play 2</span></span><br><span class="line"><span class="string"># dream eat 2</span></span><br><span class="line"><span class="string"># �?</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>上例gevent.sleep(2)模拟的是gevent可以识别的io阻塞</strong></li>
</ul>
<h2 id="�-】兼容其他IO">�?】兼容其他IO</h2>
<ul>
<li>
<p><strong>而time.sleep(2)或其他的阻塞,gevent是不能直接识别的需要用下面一行代�?打补�?就可以识别了</strong></p>
</li>
<li>
<p><strong>from gevent import monkey;monkey.patch_all()必须放到被打补丁者的前面</strong></p>
</li>
<li>
<ul>
<li><strong>如time，socket模块之前</strong></li>
</ul>
</li>
<li>
<p>*<em>或者我们干脆记忆成：要用gevent，需要将from gevent import monkey; monkey.patch_all()放到文件的开�?</em></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line"></span><br><span class="line">monkey.patch_all()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">eat</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;eat food 1&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;eat 中的 :&gt;&gt;&gt;&gt; <span class="subst">&#123;threading.current_thread()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;eat food 2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">play</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;play 1&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;play 中的 :&gt;&gt;&gt;&gt; <span class="subst">&#123;threading.current_thread()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;play 2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g1 = gevent.spawn(eat)</span><br><span class="line">g2 = gevent.spawn(play)</span><br><span class="line">gevent.joinall([g1, g2])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(threading.current_thread())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;�?)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># eat food 1</span></span><br><span class="line"><span class="string"># play 1</span></span><br><span class="line"><span class="string"># play 中的 :&gt;&gt;&gt;&gt; &lt;_DummyThread(Dummy-1, started daemon 5168389856)&gt;</span></span><br><span class="line"><span class="string"># play 2</span></span><br><span class="line"><span class="string"># eat 中的 :&gt;&gt;&gt;&gt; &lt;_DummyThread(Dummy-2, started daemon 5168390016)&gt;</span></span><br><span class="line"><span class="string"># eat food 2</span></span><br><span class="line"><span class="string"># &lt;_MainThread(MainThread, started 5168107712)&gt;</span></span><br><span class="line"><span class="string"># �?</span></span><br></pre></td></tr></table></figure>
<ul>
<li>我们可以用threading.current_thread()来查看每个g1和g2，查看的结果为DummyThread-n，即假线�?</li>
</ul>
<h1>【五】Gevent之同步与异步</h1>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> spawn, joinall, monkey</span><br><span class="line"></span><br><span class="line">monkey.patch_all()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        start = time.time()</span><br><span class="line">        res = func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;当前程序 <span class="subst">&#123;func.__name__&#125;</span> 总耗时 :&gt;&gt;&gt;&gt; <span class="subst">&#123;time.time() - start&#125;</span> s&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">pid</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Some non-deterministic task</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Task %s done&#x27;</span> % pid)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">synchronous</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        task(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">asynchronous</span>():</span><br><span class="line">    g_l = [spawn(task, i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">    joinall(g_l)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Synchronous:&#x27;</span>)</span><br><span class="line">    synchronous()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Asynchronous:&#x27;</span>)</span><br><span class="line">    asynchronous()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Synchronous:</span></span><br><span class="line">    <span class="comment"># Task 0 done</span></span><br><span class="line">    <span class="comment"># Task 1 done</span></span><br><span class="line">    <span class="comment"># Task 2 done</span></span><br><span class="line">    <span class="comment"># Task 3 done</span></span><br><span class="line">    <span class="comment"># Task 4 done</span></span><br><span class="line">    <span class="comment"># Task 5 done</span></span><br><span class="line">    <span class="comment"># Task 6 done</span></span><br><span class="line">    <span class="comment"># Task 7 done</span></span><br><span class="line">    <span class="comment"># Task 8 done</span></span><br><span class="line">    <span class="comment"># Task 9 done</span></span><br><span class="line">    <span class="comment"># 当前程序 synchronous 总耗时 :&gt;&gt;&gt;&gt; 5.034381151199341 s</span></span><br><span class="line">    <span class="comment"># Asynchronous:</span></span><br><span class="line">    <span class="comment"># Task 0 done</span></span><br><span class="line">    <span class="comment"># Task 1 done</span></span><br><span class="line">    <span class="comment"># Task 2 done</span></span><br><span class="line">    <span class="comment"># Task 3 done</span></span><br><span class="line">    <span class="comment"># Task 4 done</span></span><br><span class="line">    <span class="comment"># Task 5 done</span></span><br><span class="line">    <span class="comment"># Task 6 done</span></span><br><span class="line">    <span class="comment"># Task 7 done</span></span><br><span class="line">    <span class="comment"># Task 8 done</span></span><br><span class="line">    <span class="comment"># Task 9 done</span></span><br><span class="line">    <span class="comment"># 当前程序 asynchronous 总耗时 :&gt;&gt;&gt;&gt; 0.504889726638794 s</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面程序的重要部分是将task函数封装到Greenlet内部线程的gevent.spawn�?</span></span><br><span class="line"><span class="comment"># 初始化的greenlet列表存放在数组threads中，此数组被传给gevent.joinall 函数，后者阻塞当前流程，并执行所有给定的greenlet�?</span></span><br><span class="line"><span class="comment"># 执行流程只会�?所有greenlet执行完后才会继续向下走�?</span></span><br></pre></td></tr></table></figure>
<h1>【六】Gevent之应用举例一</h1>
<ul>
<li>协程应用：爬�?</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line"></span><br><span class="line">monkey.patch_all()</span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_page</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;当前正在获取 :&gt;&gt;&gt;&gt; <span class="subst">&#123;url&#125;</span>&quot;</span>)</span><br><span class="line">    response = requests.get(url=url)</span><br><span class="line">    <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;当前响应数据总长�?:&gt;&gt;&gt;&gt; <span class="subst">&#123;<span class="built_in">len</span>(response.text)&#125;</span> 当前链接 :&gt;&gt;&gt;&gt; <span class="subst">&#123;url&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start_time = time.time()</span><br><span class="line">gevent.joinall([</span><br><span class="line">    gevent.spawn(get_page, <span class="string">&#x27;https://www.python.org/&#x27;</span>),</span><br><span class="line">    gevent.spawn(get_page, <span class="string">&#x27;https://www.jd.com/&#x27;</span>),</span><br><span class="line">    gevent.spawn(get_page, <span class="string">&#x27;https://www.baidu.com/&#x27;</span>),</span><br><span class="line">])</span><br><span class="line">stop_time = time.time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;总耗时 :&gt;&gt;&gt;&gt; <span class="subst">&#123;stop_time - start_time&#125;</span>s&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前正在获取 :&gt;&gt;&gt;&gt; https://www.python.org/</span></span><br><span class="line"><span class="comment"># 当前正在获取 :&gt;&gt;&gt;&gt; https://www.jd.com/</span></span><br><span class="line"><span class="comment"># 当前正在获取 :&gt;&gt;&gt;&gt; https://www.baidu.com/</span></span><br><span class="line"><span class="comment"># 当前响应数据总长�?:&gt;&gt;&gt;&gt; 227 当前链接 :&gt;&gt;&gt;&gt; https://www.baidu.com/</span></span><br><span class="line"><span class="comment"># 当前响应数据总长�?:&gt;&gt;&gt;&gt; 182756 当前链接 :&gt;&gt;&gt;&gt; https://www.jd.com/</span></span><br><span class="line"><span class="comment"># 当前响应数据总长�?:&gt;&gt;&gt;&gt; 50995 当前链接 :&gt;&gt;&gt;&gt; https://www.python.org/</span></span><br><span class="line"><span class="comment"># 总耗时 :&gt;&gt;&gt;&gt; 15.546293020248413s</span></span><br></pre></td></tr></table></figure>
<h1>【七】Gevent之应用举例二</h1>
<ul>
<li>通过gevent实现单线程下的socket并发</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey;</span><br><span class="line">monkey.patch_all()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一定要放到导入socket模块之前，否则gevent无法识别socket的阻塞）</span></span><br></pre></td></tr></table></figure>
<h2 id="�-】服务端">�?】服务端</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line"></span><br><span class="line">monkey.patch_all()</span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不想用money.patch_all()打补�?可以用gevent自带的socket</span></span><br><span class="line"><span class="comment"># from gevent import socket</span></span><br><span class="line"><span class="comment"># s=socket.socket()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">server</span>(<span class="params">server_ip, port</span>):</span><br><span class="line">    s = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">    s.setsockopt(SOL_SOCKET, SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">    s.bind((server_ip, port))</span><br><span class="line">    s.listen(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        conn, addr = s.accept()</span><br><span class="line">        gevent.spawn(talk, conn, addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">talk</span>(<span class="params">conn, addr</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            res = conn.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;client %s:%s msg: %s&#x27;</span> % (addr[<span class="number">0</span>], addr[<span class="number">1</span>], res))</span><br><span class="line">            conn.send(res.upper())</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        conn.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    server(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8080</span>)</span><br></pre></td></tr></table></figure>
<h2 id="�-】客户端">�?】客户端</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">client = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">client.connect((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg = <span class="built_in">input</span>(<span class="string">&#x27;&gt;&gt;: &#x27;</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> msg: <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    client.send(msg.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    msg = client.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">print</span>(msg.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure>
<h2 id="�-】多线程并发多个客户�">�?】多线程并发多个客户�?</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">client</span>(<span class="params">server_ip, port</span>):</span><br><span class="line">    <span class="comment"># 套接字对象一定要加到函数内，即局部名称空间内</span></span><br><span class="line">    <span class="comment"># 放在函数外则被所有线程共享，则大家公用一个套接字对象，那么客户端端口永远一样了</span></span><br><span class="line">    c = socket(AF_INET, SOCK_STREAM)  </span><br><span class="line">    c.connect((server_ip, port))</span><br><span class="line"></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        c.send((<span class="string">&#x27;%s say hello %s&#x27;</span> % (threading.current_thread().getName(), count)).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        msg = c.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="built_in">print</span>(msg.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">500</span>):</span><br><span class="line">        t = Thread(target=client, args=(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8080</span>))</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure>
<h1>协程操作</h1>
<ul>
<li>基于 async �?await 关键字的协程可以实现异步编程，这也是目前 Python 异步相关的主流技术。在这里我们主要介绍一下实现异步的模块：asyncio 模块</li>
</ul>
<h1>【一】asyncio 模块</h1>
<ul>
<li>asyncio 模块�?Python 中实现异步的一个模块，该模块在 Python3.4 的时候发�?</li>
<li>async �?await 关键字在 Python3.5 中引入�?</li>
<li>因此，想要使用asyncio模块，建�?Python 解释器的版本不要低于 Python3.5 �?</li>
</ul>
<h1>【二】事件循�?</h1>
<ul>
<li>所谓的事件循环，我们可以把它当作是一�?while 循环，这�?while 循环在循环生命周期内运行并执行一些任务，在特定的条件下结束循环�?</li>
<li>在编写程序的时候可以通过如下代码来获取和创建事件循环�?</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br></pre></td></tr></table></figure>
<h1>【三】协程函数和协程对象</h1>
<h2 id="�-】什么是协程函数">�?】什么是协程函数</h2>
<ul>
<li>
<p>首先我们来看一下协程函�?</p>
</li>
<li>
<ul>
<li>什么是协程函数呢？</li>
</ul>
</li>
<li>
<p>直白的讲，定义为如下形式的函�?</p>
</li>
<li>
<p>我们可以称之为协程函数，如下代码所示：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 async 声明的函数就是协程函�?</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fn</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h2 id="�-】什么是协程对象">�?】什么是协程对象</h2>
<ul>
<li>
<p>知道了什么是协程函数</p>
</li>
<li>
<ul>
<li>接下来我们再来看一下什么是协程对象</li>
<li>所谓的协程对象就是调用协程函数之后返回的对�?</li>
<li>我们称之�?<strong>协程对象</strong>，如下代码所示：</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 async 声明的函数就是协程函�?</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fn</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用携程函数得到的对象就是协程对�?</span></span><br><span class="line">res = fn()</span><br><span class="line"><span class="built_in">print</span>(res) <span class="comment"># &lt;coroutine object fn at 0x1029684a0&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注意事项：调用协程函数时，函数内部的代码不会执行，只是会返回一个协程对象！</li>
</ul>
<h1>【四】协程函数应�?</h1>
<h2 id="�-】基本应�">�?】基本应�?</h2>
<ul>
<li>在编写程序的时候，如果想要执行协程函数内部的代码，通过 <strong>函数�?)</strong> 调用函数是不可以的，需�?<strong>事件循环</strong> �?<strong>协程对象</strong> 配合才能实现，如下代码所示：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fn</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;协程函数内部的代�?)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 执行协程代码的方式一</span></span><br><span class="line"><span class="string">def main_first():</span></span><br><span class="line"><span class="string">    # 调用协程函数，返回一个协程对�?</span></span><br><span class="line"><span class="string">    res = fn()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    # todo�?、创建一个事件循�?</span></span><br><span class="line"><span class="string">    loop = asyncio.get_event_loop()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    # todo�?、将协程当作任务提交到事件循环的任务列表中，协程执行完成之后终止</span></span><br><span class="line"><span class="string">    loop.run_until_complete(res)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 执行协程代码的方式二</span></span><br><span class="line"><span class="string">def main_second():</span></span><br><span class="line"><span class="string">    # 调用协程函数，返回一个协程对�?</span></span><br><span class="line"><span class="string">    res = fn()</span></span><br><span class="line"><span class="string">    # 解析：第二种方式在本质上和第一种方式是相同的，其内部先创建事件循环，然后执�?run_until_complete</span></span><br><span class="line"><span class="string">    # 但是要注意：该方式只支持 Python3.7+ 的解释器，因为该方式�?Python3.7 加入的�?</span></span><br><span class="line"><span class="string">    asyncio.run(res)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if __name__ == &#x27;</span>__main__<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">    main_first()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    main_second()</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>这个过程可以简单理解为�?</p>
</li>
<li>
<ul>
<li>�?<strong>协程函数</strong> 当做任务添加�?<strong>事件循环</strong> 的任务列�?</li>
<li>然后事件循环检测列表中�?<em>协程函数</em>* 是否已准备就绪（默认可理解为就绪状态）</li>
<li>如果准备就绪则执行其内部代码�?</li>
</ul>
</li>
</ul>
<h2 id="�-】await关键�">�?】await关键�?</h2>
<ul>
<li>await 是一�?只能 在协程函数中使用的关键字，用于当协程函数遇到IO操作的时候挂起当前协程（任务），</li>
<li>当前协程挂起过程中，事件循环可以去执行其他的协程（任务）</li>
<li>当前协程IO处理完成时，可以再次切换回来执行 await 之后的代�?</li>
<li>怎么理解呢？请看如下代码�?</li>
</ul>
<h3 id="�-�-实例1">�?�?<em>实例1</em>*</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fn</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;协程函数内部的代�?)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    # 遇到IO操作之后挂起当前协程（任务），等IO操作完成之后再继续往下执行�?</span></span><br><span class="line"><span class="string">    # 当前协程挂起时，事件循环可以去执行其他协程（任务�?</span></span><br><span class="line"><span class="string">    response = await asyncio.sleep(2)  # 模拟遇到了IO操作</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    print(f&#x27;</span>IO请求结束，结果为：&#123;response&#125;<span class="string">&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def main():</span></span><br><span class="line"><span class="string">    # 调用协程函数，返回一个协程对�?</span></span><br><span class="line"><span class="string">    res = fn()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    # 执行协程函数</span></span><br><span class="line"><span class="string">    asyncio.run(res)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if __name__ == &#x27;</span>__main__<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">    main()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">    运行结果�?</span><br><span class="line">    协程函数内部的代�?</span><br><span class="line">    IO请求结束，结果为：<span class="literal">None</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="�-�-实例2">�?�?<em>实例2</em>*</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">other_tasks</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)  <span class="comment"># 模拟遇到了IO操作</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;返回�?</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">async def fn():</span></span><br><span class="line"><span class="string">    print(&#x27;</span>协程函数内部的代�?)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遇到IO操作之后挂起当前协程（任务），等IO操作完成之后再继续往下执行�?</span></span><br><span class="line">    <span class="comment"># 当前协程挂起时，事件循环可以去执行其他协程（任务�?</span></span><br><span class="line">    response = <span class="keyword">await</span> other_tasks()  <span class="comment"># 模拟执行其他协程任务</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;IO请求结束，结果为：<span class="subst">&#123;response&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 调用协程函数，返回一个协程对�?</span></span><br><span class="line">    res = fn()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 执行协程函数</span></span><br><span class="line">    asyncio.run(res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    运行结果�?</span></span><br><span class="line"><span class="string">    协程函数内部的代�?</span></span><br><span class="line"><span class="string">    start</span></span><br><span class="line"><span class="string">    end</span></span><br><span class="line"><span class="string">    IO请求结束，结果为：返回�?</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="�-）实�">�?）实�?</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">other_tasks</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)  <span class="comment"># 模拟遇到了IO操作</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;返回�?</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">async def fn():</span></span><br><span class="line"><span class="string">    print(&#x27;</span>协程函数内部的代�?)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遇到IO操作之后挂起当前协程（任务），等IO操作完成之后再继续往下执行�?</span></span><br><span class="line">    <span class="comment"># 当前协程挂起时，事件循环可以去执行其他协程（任务�?</span></span><br><span class="line">    respnse1 = <span class="keyword">await</span> other_tasks()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;IO请求结束，结果为：<span class="subst">&#123;respnse1&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    respnse2 = <span class="keyword">await</span> other_tasks()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;IO请求结束，结果为：<span class="subst">&#123;respnse2&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 调用协程函数，返回一个协程对�?</span></span><br><span class="line">    cor_obj = fn()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 执行协程函数</span></span><br><span class="line">    asyncio.run(cor_obj)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line">    </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    运行结果�?</span></span><br><span class="line"><span class="string">    协程函数内部的代�?</span></span><br><span class="line"><span class="string">    start</span></span><br><span class="line"><span class="string">    end</span></span><br><span class="line"><span class="string">    IO请求结束，结果为：返回�?</span></span><br><span class="line"><span class="string">    start</span></span><br><span class="line"><span class="string">    end</span></span><br><span class="line"><span class="string">    IO请求结束，结果为：返回�?</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="�-）小�">�?）小�?</h3>
<ul>
<li>
<p>上述的所有实例都只是创建了一个任�?</p>
</li>
<li>
<ul>
<li>即：事件循环的任务列表中只有一个任�?</li>
<li>所以在IO等待时无法演示切换到其他任务效果�?</li>
</ul>
</li>
<li>
<p>在程序中想要创建多个任务对象</p>
</li>
<li>
<ul>
<li>需要使用Task对象来实现�?</li>
</ul>
</li>
</ul>
<h2 id="�-】Task-对象">�?】Task 对象</h2>
<ul>
<li>
<p>Tasks 用于并发调度协程</p>
</li>
<li>
<p>通过 asyncio.create_task(协程对象) 的方式创�?Task 对象</p>
</li>
<li>
<p>这样可以让协程加入事件循环中等待被调度执行�?</p>
</li>
<li>
<p>除了使用 asyncio.create_task() 函数以外</p>
</li>
<li>
<p>还可以用低层级的loop.create_task() �?ensure_future() 函数。并且不建议手动实例�?Task 对象�?</p>
</li>
<li>
<p>本质上是将协程对象封装成 Task 对象</p>
</li>
<li>
<p>并将协程立即加入事件循环，同时追踪协程的状态�?</p>
</li>
<li>
<p>注意事项�?</p>
</li>
<li>
<ul>
<li>asyncio.create_task() 函数�?Python3.7 中被加入�?</li>
<li>�?Python3.7 之前，可以改用低层级�?</li>
<li>asyncio.ensure_future() 函数�?</li>
</ul>
</li>
</ul>
<h3 id="�-）协程运行方式一">�?）协程运行方式一</h3>
<ul>
<li>async.run() 运行协程</li>
<li>async.create_task()创建task</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">other_tasks</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)  <span class="comment"># 模拟遇到了IO操作</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;返回�?</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">async def fn():</span></span><br><span class="line"><span class="string">    print(&#x27;</span>fn开�?)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建协程，将协程封装到一个Task对象中并立即添加到事件循环的任务列表中，等待事件循环去执行（默认是就绪状态）�?</span></span><br><span class="line">    task1 = asyncio.create_task(other_tasks())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建协程，将协程封装到一个Task对象中并立即添加到事件循环的任务列表中，等待事件循环去执行（默认是就绪状态）�?</span></span><br><span class="line">    task2 = asyncio.create_task(other_tasks())</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;fn结束&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当执行某协程遇到IO操作时，会自动化切换执行其他任务�?</span></span><br><span class="line">    <span class="comment"># 此处的await是等待相对应的协程全都执行完毕并获取结果</span></span><br><span class="line">    response1 = <span class="keyword">await</span> task1</span><br><span class="line">    response2 = <span class="keyword">await</span> task2</span><br><span class="line">    <span class="built_in">print</span>(response1, response2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    asyncio.run(fn())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    运行结果�?</span></span><br><span class="line"><span class="string">    fn开�?</span></span><br><span class="line"><span class="string">    fn结束</span></span><br><span class="line"><span class="string">    start</span></span><br><span class="line"><span class="string">    start</span></span><br><span class="line"><span class="string">    end</span></span><br><span class="line"><span class="string">    end</span></span><br><span class="line"><span class="string">    返回�?返回�?</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="�-）协程运行方式二">�?）协程运行方式二</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">other_tasks</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)  <span class="comment"># 模拟遇到了IO操作</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;返回�?</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">async def fn():</span></span><br><span class="line"><span class="string">    print(&#x27;</span>fn开�?)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建协程，将协程封装到一个Task对象中并立即添加到事件循环的任务列表中，等待事件循环去执行（默认是就绪状态）�?</span></span><br><span class="line">    task_lis = [</span><br><span class="line">        asyncio.create_task(other_tasks()),</span><br><span class="line">        asyncio.create_task(other_tasks()),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;fn结束&#x27;</span>)</span><br><span class="line">    <span class="comment"># 当执行某协程遇到IO操作时，会自动化切换执行其他任务�?</span></span><br><span class="line">    <span class="comment"># 此处的await是等待所有协程执行完毕，并将所有协程的返回值保存到done</span></span><br><span class="line">    <span class="comment"># 如果设置了timeout值，则意味着此处最多等待的秒，完成的协程返回值写入到done中，未完成则写到pending中�?</span></span><br><span class="line">    done, pending = <span class="keyword">await</span> asyncio.wait(task_lis, timeout=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;done :&gt;&gt;&gt;&gt; <span class="subst">&#123;done&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;pending :&gt;&gt;&gt;&gt; <span class="subst">&#123;pending&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    asyncio.run(fn())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    fn开�?</span></span><br><span class="line"><span class="string">    fn结束</span></span><br><span class="line"><span class="string">    start</span></span><br><span class="line"><span class="string">    start</span></span><br><span class="line"><span class="string">    end</span></span><br><span class="line"><span class="string">    end</span></span><br><span class="line"><span class="string">    done :&gt;&gt;&gt;&gt; &#123;&lt;Task finished name=&#x27;Task-2&#x27; coro=&lt;other_tasks() done, defined at /Users/dream/Desktop/PythonProjects/12并发编程/02协程/01.py:4&gt; result=&#x27;返回�?&gt;, &lt;Task finished name=&#x27;Task-3&#x27; coro=&lt;other_tasks() done, defined at /Users/dream/Desktop/PythonProjects/12并发编程/02协程/01.py:4&gt; result=&#x27;返回�?&gt;&#125;</span></span><br><span class="line"><span class="string">    pending :&gt;&gt;&gt;&gt; set()</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="�-）获取协程返回�">�?）获取协程返回�?</h3>
<ul>
<li>async.gather()获取返回�?</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">other_tasks</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)  <span class="comment"># 模拟遇到了IO操作</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;返回�?</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">async def fn():</span></span><br><span class="line"><span class="string">    print(&#x27;</span>fn开�?)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建协程，将协程封装到一个Task对象中并立即添加到事件循环的任务列表中，等待事件循环去执行（默认是就绪状态）�?</span></span><br><span class="line">    task_lis = [</span><br><span class="line">        asyncio.create_task(other_tasks()),</span><br><span class="line">        asyncio.create_task(other_tasks()),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;fn结束&#x27;</span>)</span><br><span class="line">    <span class="comment"># 当执行某协程遇到IO操作时，会自动化切换执行其他任务�?</span></span><br><span class="line">    <span class="comment"># 此处的await是等待所有协程执行完毕，并将所有协程的返回值保存到done</span></span><br><span class="line">    <span class="comment"># 如果设置了timeout值，则意味着此处最多等待的秒，完成的协程返回值写入到done中，未完成则写到pending中�?</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.wait(task_lis, timeout=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    response = <span class="keyword">await</span> asyncio.gather(task_lis[<span class="number">0</span>], task_lis[<span class="number">1</span>])  <span class="comment"># 将task_lis作为参数传入gather，等异步任务都结束后返回结果列表</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;response :&gt;&gt;&gt;&gt; <span class="subst">&#123;response&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    asyncio.run(fn())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    fn开�?</span></span><br><span class="line"><span class="string">    fn结束</span></span><br><span class="line"><span class="string">    start</span></span><br><span class="line"><span class="string">    start</span></span><br><span class="line"><span class="string">    end</span></span><br><span class="line"><span class="string">    end</span></span><br><span class="line"><span class="string">    response :&gt;&gt;&gt;&gt; [&#x27;返回�?, &#x27;返回�?]</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="�-】aiohtpp对象">�?】aiohtpp对象</h2>
<ul>
<li>
<p>我们之前学习过爬虫最重要的模块requests，但它是阻塞式的发起请求，每次请求发起后需阻塞等待其返回响应，不能做其他的事情�?</p>
</li>
<li>
<ul>
<li>本文要介绍的aiohttp可以理解成是和requests对应Python异步网络请求库，它是基于 asyncio 的异步模块，可用于实现异步爬虫，有点就是更快�?requests 的同步爬虫�?</li>
<li>安装方式，pip install aiohttp�?</li>
</ul>
</li>
<li>
<p>aiohttp是一个为Python提供异步HTTP 客户�?服务端编程，基于asyncio的异步库�?</p>
</li>
<li>
<ul>
<li>asyncio可以实现单线程并发IO操作，其实现了TCP、UDP、SSL等协议，</li>
<li>aiohttp就是基于asyncio实现的http框架�?</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.get(<span class="string">&quot;http://httpbin.org/headers&quot;</span>) <span class="keyword">as</span> response:</span><br><span class="line">            <span class="built_in">print</span>(<span class="keyword">await</span> response.text())</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<h1>【五】异步迭代器</h1>
<h2 id="�-】什么是异步迭代器？">�?】什么是异步迭代器？</h2>
<ul>
<li>实现�?<strong>aiter</strong>() �?<strong>anext</strong>()方法的对象�?</li>
<li><strong>anext</strong> 必须返回一�?awaitable 对象�?</li>
<li>async for会处理异步迭代器�?<strong>anext</strong>()方法所返回的可等待对象，直到其引发一�?StopAsyncIteration异常�?</li>
</ul>
<h2 id="�-】什么是异步可迭代对象？">�?】什么是异步可迭代对象？</h2>
<ul>
<li>可在 async for语句中被使用的对象�?</li>
<li>必须通过它的 <strong>aiter</strong>()方法返回一�?asynchronous iterator �?</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Reader</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 自定义异步迭代器（同时也是异步可迭代对象�?&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">readline</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.count == <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.count</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__aiter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">__anext__</span>(<span class="params">self</span>):</span><br><span class="line">        val = <span class="keyword">await</span> <span class="variable language_">self</span>.readline()</span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopAsyncIteration</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fn</span>():</span><br><span class="line">    <span class="comment"># 创建异步可迭代对�?</span></span><br><span class="line"></span><br><span class="line">    async_iter = Reader()</span><br><span class="line">    <span class="comment"># async for 必须放在async def 函数内，否则语法错误�?</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">for</span> item <span class="keyword">in</span> async_iter:</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run((fn()))</span><br></pre></td></tr></table></figure>
<h1>【六】异步上下文管理�?</h1>
<ul>
<li>此种对象通过定义 <strong>aenter</strong>() �?<strong>aexit</strong>() 方法来对 <em>async with</em> 语句中的环境进行控制�?</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AsyncContextManager</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.conn = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">do_something</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 异步操作数据�?</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">__aenter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 异步链接数据�?</span></span><br><span class="line">        <span class="variable language_">self</span>.conn = <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">__aexit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span><br><span class="line">        <span class="comment"># 异步关闭数据库链�?</span></span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fn</span>():</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> AsyncContextManager() <span class="keyword">as</span> f:</span><br><span class="line">        res = <span class="keyword">await</span> f.do_something()</span><br><span class="line">        <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(fn())</span><br></pre></td></tr></table></figure>
<h1>【七】小�?</h1>
<ul>
<li>在程序中只要看到 <em>async</em> �?<em>await</em> 关键�?</li>
<li>其内部就是基于协程实现的异步编程</li>
<li>这种异步编程是通过一个线程在IO等待时间去执行其他任务，从而实现并发�?</li>
</ul>
<p>以上就是异步编程的常见操作，更多内容请参�?Python 官方文档：<a href="d2dbc46621cc5538ec739f56976641e3">https://docs.python.org/zh-cn/3.8/library/asyncio.html</a></p>
<h1>【八】小试牛刀</h1>
<ul>
<li>需求：访问苹果官网 50 次，测试其总访问时间�?</li>
</ul>
<h2 id="�-�-同步版本">�?�?<em>同步版本</em>*</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calc_visit_time</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算程序的执行时�?*</span></span><br><span class="line"><span class="string">    :param url:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    start_time = time.time()</span><br><span class="line">    <span class="keyword">for</span> times <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">51</span>):</span><br><span class="line">        response = requests.get(url=url)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;第【<span class="subst">&#123;times&#125;</span>】次链接成功�?)</span></span><br><span class="line"><span class="string">    else:</span></span><br><span class="line"><span class="string">        print(f&#x27;</span>链接失败�?.center(<span class="number">50</span>, <span class="string">&#x27;-&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    end_time = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;任务消耗了<span class="subst">&#123;end_time - start_time&#125;</span>秒的时间�?)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def main():</span></span><br><span class="line"><span class="string">    calc_visit_time(&#x27;</span>https://www.baidu.com<span class="string">&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if __name__ == &#x27;</span>__main__<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">    main()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">    运行结果�?</span><br><span class="line">    第�?】次链接成功�?</span><br><span class="line">    第�?】次链接成功�?</span><br><span class="line">    第�?】次链接成功�?</span><br><span class="line">    第�?】次链接成功�?</span><br><span class="line">    第�?】次链接成功�?</span><br><span class="line">    ...</span><br><span class="line">    第�?<span class="number">6</span>】次链接成功�?</span><br><span class="line">    第�?<span class="number">7</span>】次链接成功�?</span><br><span class="line">    第�?<span class="number">8</span>】次链接成功�?</span><br><span class="line">    第�?<span class="number">9</span>】次链接成功�?</span><br><span class="line">    第�?<span class="number">0</span>】次链接成功�?</span><br><span class="line">    任务消耗了<span class="number">5.65</span>秒的时间�?</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="�-】异步版�">�?】异步版�?</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 异步版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fetch_async</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    异步的aiohttp模块，替代了之前的同步的requests模块</span></span><br><span class="line"><span class="string">    :param url:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        <span class="comment"># 跳过证书验证 :&gt;&gt;&gt;&gt; ssl=False</span></span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.get(url=url, ssl=<span class="literal">False</span>) <span class="keyword">as</span> response:</span><br><span class="line">            <span class="keyword">if</span> response.status == <span class="number">200</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;链接成功�?)</span></span><br><span class="line"><span class="string">            else:</span></span><br><span class="line"><span class="string">                print(f&#x27;</span>链接失败�?.center(<span class="number">50</span>, <span class="string">&#x27;-&#x27;</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">calc_visit_time</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算程序的执行时�?</span></span><br><span class="line"><span class="string">    :param url:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    start_time = time.time()</span><br><span class="line">    task_lis = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">        task_lis.append(fetch_async(url))</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(*task_lis)</span><br><span class="line">    end_time = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;任务消耗了<span class="subst">&#123;end_time - start_time&#125;</span>秒的时间�?)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def main():</span></span><br><span class="line"><span class="string">    asyncio.run(calc_visit_time(&#x27;</span>https://www.baidu.com<span class="string">&#x27;))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if __name__ == &#x27;</span>__main__<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">    main()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">    运行结果�?</span><br><span class="line">    链接成功�?</span><br><span class="line">    链接成功�?</span><br><span class="line">    链接成功�?</span><br><span class="line">    链接成功�?</span><br><span class="line">    链接成功�?</span><br><span class="line">    ...</span><br><span class="line">    链接成功�?</span><br><span class="line">    链接成功�?</span><br><span class="line">    链接成功�?</span><br><span class="line">    链接成功�?</span><br><span class="line">    链接成功�?</span><br><span class="line">    任务消耗了<span class="number">0.31</span>秒的时间�?</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>通过上述两个实例的运行结果，我们可以看到，使用了异步之后，其效率提升18倍�?</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Blog/" rel="tag"># Blog</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/01/01/3.6IO%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B/" rel="prev" title="3.6IOģ�ͼ��">
      <i class="fa fa-chevron-left"></i> 3.6IOģ�ͼ��
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/01/01/3.4%E8%BF%9B%E7%A8%8B%E6%B1%A0%EF%BC%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/" rel="next" title="3.4���̳أ��̳߳�">
      3.4���̳أ��̳߳� <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">1.</span> <span class="nav-text">协程理论</span></a></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">2.</span> <span class="nav-text">【一】基于单线程来实现并�?</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BF%BD-%E3%80%91%E5%B9%B6%E5%8F%91%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="nav-number">2.1.</span> <span class="nav-text">�?】并发的本质</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BF%BD-%E3%80%91yield%E5%85%B3%E9%94%AE%EF%BF%BD"><span class="nav-number">2.2.</span> <span class="nav-text">�?】yield关键�?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BF%BD-%EF%BC%89%E4%B8%B2%E8%A1%8C%E6%89%A7%EF%BF%BD"><span class="nav-number">2.2.1.</span> <span class="nav-text">�?）串行执�?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BF%BD-%EF%BC%89%E5%9F%BA%E4%BA%8Eyield%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C"><span class="nav-number">2.2.2.</span> <span class="nav-text">�?）基于yield并发执行</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BF%BD-%E3%80%91%E5%AE%9E%E7%8E%B0%E9%81%87%E5%88%B0IO%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2"><span class="nav-number">2.3.</span> <span class="nav-text">�?】实现遇到IO自动切换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">3.</span> <span class="nav-text">【二】协程介�?</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BF%BD-%E3%80%91%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E7%A8%8B"><span class="nav-number">3.1.</span> <span class="nav-text">�?】什么是协程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BF%BD-%E3%80%91%E4%BC%98%EF%BF%BD"><span class="nav-number">3.2.</span> <span class="nav-text">�?】优�?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BF%BD-%E3%80%91%E7%BC%BA%EF%BF%BD"><span class="nav-number">3.3.</span> <span class="nav-text">�?】缺�?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BF%BD-%E3%80%91%E6%80%BB%E7%BB%93"><span class="nav-number">3.4.</span> <span class="nav-text">�?】总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">4.</span> <span class="nav-text">【三】Greenlet</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BF%BD-%E3%80%91%E5%AE%89%EF%BF%BD"><span class="nav-number">4.1.</span> <span class="nav-text">�?】安�?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BF%BD-%E3%80%91%E4%BD%BF%EF%BF%BD"><span class="nav-number">4.2.</span> <span class="nav-text">�?】使�?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BF%BD-%E3%80%91%E5%8D%95%E7%BA%AF%E5%88%87%E6%8D%A2%E9%99%8D%E4%BD%8E%E6%95%88%EF%BF%BD"><span class="nav-number">4.3.</span> <span class="nav-text">�?】单纯切换降低效�?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BF%BD-%EF%BC%89%E9%A1%BA%E5%BA%8F%E6%89%A7%EF%BF%BD"><span class="nav-number">4.3.1.</span> <span class="nav-text">�?）顺序执�?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BF%BD-%EF%BC%89%E5%88%87%E6%8D%A2%E6%89%A7%EF%BF%BD"><span class="nav-number">4.3.2.</span> <span class="nav-text">�?）切换执�?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BF%BD-%E3%80%91%E5%B0%8F%EF%BF%BD"><span class="nav-number">4.4.</span> <span class="nav-text">�?】小�?</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">5.</span> <span class="nav-text">【四】Gevent介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BF%BD-%E3%80%91%E4%BB%8B%EF%BF%BD"><span class="nav-number">5.1.</span> <span class="nav-text">�?】介�?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BF%BD-%EF%BF%BD-%E5%AE%89%E8%A3%85"><span class="nav-number">5.2.</span> <span class="nav-text">�?�?安装*</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BF%BD-%E3%80%91%E4%BD%BF%EF%BF%BD-2"><span class="nav-number">5.3.</span> <span class="nav-text">�?】使�?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BF%BD-%EF%BF%BD-%E9%81%87%E5%88%B0IO%E9%98%BB%E5%A1%9E%E6%97%B6%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E4%BB%BB%E5%8A%A1"><span class="nav-number">5.4.</span> <span class="nav-text">�?�?遇到IO阻塞时会自动切换任务*</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BF%BD-%E3%80%91%E5%85%BC%E5%AE%B9%E5%85%B6%E4%BB%96IO"><span class="nav-number">5.5.</span> <span class="nav-text">�?】兼容其他IO</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">6.</span> <span class="nav-text">【五】Gevent之同步与异步</span></a></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">7.</span> <span class="nav-text">【六】Gevent之应用举例一</span></a></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">8.</span> <span class="nav-text">【七】Gevent之应用举例二</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BF%BD-%E3%80%91%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="nav-number">8.1.</span> <span class="nav-text">�?】服务端</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BF%BD-%E3%80%91%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-number">8.2.</span> <span class="nav-text">�?】客户端</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BF%BD-%E3%80%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%A4%9A%E4%B8%AA%E5%AE%A2%E6%88%B7%EF%BF%BD"><span class="nav-number">8.3.</span> <span class="nav-text">�?】多线程并发多个客户�?</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">9.</span> <span class="nav-text">协程操作</span></a></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">10.</span> <span class="nav-text">【一】asyncio 模块</span></a></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">11.</span> <span class="nav-text">【二】事件循�?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">12.</span> <span class="nav-text">【三】协程函数和协程对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BF%BD-%E3%80%91%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E7%A8%8B%E5%87%BD%E6%95%B0"><span class="nav-number">12.1.</span> <span class="nav-text">�?】什么是协程函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BF%BD-%E3%80%91%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E7%A8%8B%E5%AF%B9%E8%B1%A1"><span class="nav-number">12.2.</span> <span class="nav-text">�?】什么是协程对象</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">13.</span> <span class="nav-text">【四】协程函数应�?</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BF%BD-%E3%80%91%E5%9F%BA%E6%9C%AC%E5%BA%94%EF%BF%BD"><span class="nav-number">13.1.</span> <span class="nav-text">�?】基本应�?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BF%BD-%E3%80%91await%E5%85%B3%E9%94%AE%EF%BF%BD"><span class="nav-number">13.2.</span> <span class="nav-text">�?】await关键�?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BF%BD-%EF%BF%BD-%E5%AE%9E%E4%BE%8B1"><span class="nav-number">13.2.1.</span> <span class="nav-text">�?�?实例1*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BF%BD-%EF%BF%BD-%E5%AE%9E%E4%BE%8B2"><span class="nav-number">13.2.2.</span> <span class="nav-text">�?�?实例2*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BF%BD-%EF%BC%89%E5%AE%9E%EF%BF%BD"><span class="nav-number">13.2.3.</span> <span class="nav-text">�?）实�?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BF%BD-%EF%BC%89%E5%B0%8F%EF%BF%BD"><span class="nav-number">13.2.4.</span> <span class="nav-text">�?）小�?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BF%BD-%E3%80%91Task-%E5%AF%B9%E8%B1%A1"><span class="nav-number">13.3.</span> <span class="nav-text">�?】Task 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BF%BD-%EF%BC%89%E5%8D%8F%E7%A8%8B%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F%E4%B8%80"><span class="nav-number">13.3.1.</span> <span class="nav-text">�?）协程运行方式一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BF%BD-%EF%BC%89%E5%8D%8F%E7%A8%8B%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F%E4%BA%8C"><span class="nav-number">13.3.2.</span> <span class="nav-text">�?）协程运行方式二</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BF%BD-%EF%BC%89%E8%8E%B7%E5%8F%96%E5%8D%8F%E7%A8%8B%E8%BF%94%E5%9B%9E%EF%BF%BD"><span class="nav-number">13.3.3.</span> <span class="nav-text">�?）获取协程返回�?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BF%BD-%E3%80%91aiohtpp%E5%AF%B9%E8%B1%A1"><span class="nav-number">13.4.</span> <span class="nav-text">�?】aiohtpp对象</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">14.</span> <span class="nav-text">【五】异步迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BF%BD-%E3%80%91%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%82%E6%AD%A5%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%9F"><span class="nav-number">14.1.</span> <span class="nav-text">�?】什么是异步迭代器？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BF%BD-%E3%80%91%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%82%E6%AD%A5%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="nav-number">14.2.</span> <span class="nav-text">�?】什么是异步可迭代对象？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">15.</span> <span class="nav-text">【六】异步上下文管理�?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">16.</span> <span class="nav-text">【七】小�?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">17.</span> <span class="nav-text">【八】小试牛刀</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BF%BD-%EF%BF%BD-%E5%90%8C%E6%AD%A5%E7%89%88%E6%9C%AC"><span class="nav-number">17.1.</span> <span class="nav-text">�?�?同步版本*</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BF%BD-%E3%80%91%E5%BC%82%E6%AD%A5%E7%89%88%EF%BF%BD"><span class="nav-number">17.2.</span> <span class="nav-text">�?】异步版�?</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">坤</p>
  <div class="site-description" itemprop="description">选择有时候比努力更重要，但是你不努力，选择就只是空谈</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">201</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">坤</span>
</div>
  <div class="powered-by">由 <a href="https://github.com/lsk-0912" class="theme-link" rel="noopener" target="_blank">lsk-0912</a> & <a href="https://github.com/lsk-0912" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
