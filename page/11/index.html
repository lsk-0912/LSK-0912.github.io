<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 8.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"aurora-lsk.asia","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="选择有时候比努力更重要，但是你不努力，选择就只是空谈">
<meta property="og:type" content="website">
<meta property="og:title" content="坤博客">
<meta property="og:url" content="https://aurora-lsk.asia/page/11/index.html">
<meta property="og:site_name" content="坤博客">
<meta property="og:description" content="选择有时候比努力更重要，但是你不努力，选择就只是空谈">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="坤">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://aurora-lsk.asia/page/11/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>坤博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">坤博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aurora-lsk.asia/2025/10/15/5.10%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%8C%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="坤">
      <meta itemprop="description" content="选择有时候比努力更重要，但是你不努力，选择就只是空谈">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="坤博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/15/5.10%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%8C%E7%B1%BB/" class="post-title-link" itemprop="url">5.10面向对象，类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-10-15 11:34:55 / 修改时间：16:15:50" itemprop="dateCreated datePublished" datetime="2025-10-15T11:34:55+08:00">2025-10-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Blog/" itemprop="url" rel="index"><span itemprop="name">Blog</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>面向对象</h1>
<h1>【一】简介----》引入</h1>
<ul>
<li>将数据和功能进行绑定</li>
<li>不再是所有数据都可以调用任意的功能</li>
<li>上述将数据与功能整合到</li>
<li>可以理解为：可以理解我们写的面条版程序，一步接着做</li>
</ul>
```python
#引入例题
# 定义专门用来描述人和狗的函数(最好单独编写)
def get_person(name, gender, age, t_type, attack_val, life_val):
    data_dict = {
        'name': name,
        'gender': gender,
        'age': age,
        't_type': t_type,
        'attack_val': attack_val,
        'life_val': life_val
    }
    return data_dict


def get_dog(name, t_type, attack_val, life_val):
    data_dict = {
        'name': name,
        't_type': t_type,
        'attack_val': attack_val,
        'life_val': life_val
    }
    return data_dict


p1 = get_person('dream', 'male', 18, '猛男', 800, 1000)
p2 = get_person('hope', 'female', 28, '淑女', 5, 100)
dog1 = get_dog('小黑', '松狮犬', 300, 500)
dog2 = get_dog('小白', '泰迪犬', 50, 200)


# 定义一个函数用来描述人和狗的攻击行为
def dog_attack(dog_obj, person_obj):
    """
    :param dog_obj: 接收一条狗
    :param person_obj: 接收一个人
    """
    # 使用最简答的掉血逻辑  血量减去对方攻击力
    print('当前人的血量是:%s' % person_obj.get('life_val'))
    person_obj['life_val'] -= dog_obj.get('attack_val')
    print("""狗:%s 咬了人:%s 一口 人掉血:%s 剩余血量:%s""" % (
        dog_obj.get('name'), person_obj.get('name'), dog_obj.get('attack_val'), person_obj['life_val']))


def person_attack(person_obj, dog_obj):
    """
    :param person_obj: 接收一个人
    :param dog_obj: 接收一条狗
    """
    print('当前狗的血量是:%s' % dog_obj.get('life_val'))
    dog_obj['life_val'] -= person_obj.get('attack_val')
    print("""人:%s 锤了狗:%s 一下 狗掉血:%s 剩余血量:%s""" % (
        person_obj.get('name'), dog_obj.get('name'), person_obj.get('attack_val'), dog_obj['life_val']))


# 狗咬人
dog_attack(dog2, p1)
print(p1)
# 人锤狗
person_attack(p2, dog1)
print(dog1)

'''人调用了狗的攻击动作'''
dog_attack(p1, dog1)
'''狗调用了人的攻击工作'''
person_attack(dog2, p2)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 【二】面向对象和 面向过程</span><br><span class="line"></span><br><span class="line">## 【1】面向过程</span><br><span class="line"></span><br><span class="line">- 核心在于&quot;过程&quot;</span><br><span class="line">  - **将程序&quot;流程化&quot;**</span><br><span class="line">- 过程就像流水线，用来分步骤解决问题</span><br><span class="line">- 过程指是解决问题的步骤，先干什么在干什么</span><br><span class="line">- 面向对象的设计就好比精心设计好一条流水线，是一种机械式的思维方式。</span><br><span class="line"></span><br><span class="line">## 【2】优点，缺点</span><br><span class="line"></span><br><span class="line">- 优点</span><br><span class="line">  - 复杂度的问题流程化，进而简单化（一个复杂的问题，分成一个个小步骤，去实现晓得步骤就会相对简单）</span><br><span class="line"></span><br><span class="line">- 缺点</span><br><span class="line">  - 一套流水线或者流程就是用来解决一个问题。改一个组件，牵一发而动全身。</span><br><span class="line"></span><br><span class="line">## 【3】面向对象</span><br><span class="line"></span><br><span class="line">- 核心在于&quot;对象&quot;二字。</span><br><span class="line">- 对象的终级奥秘就是将程序&quot;整合&quot;。</span><br><span class="line">- 对象就是&quot;容器&quot;，用来存放数据与功能</span><br><span class="line"></span><br><span class="line">- 文字版理解</span><br><span class="line">  - 面向对象就相当于上帝，在上帝的视角，人是对象，动物是对象，石头是对象，水是对象，山是对象.....存在的可以扩充，不存在的可以创造。</span><br><span class="line"></span><br><span class="line">- **可以这样理解面向对象就像我们要设计的校园模拟器，需要在校园中创造各种生活场景。**</span><br><span class="line">  - **一个学校：下面有学生，老师，运动员等。。。**</span><br><span class="line">  - **而每一个角色都会对应其具有的责任和功能**</span><br><span class="line">    - **比如一个学生具有姓名、年龄、性别、所在班级等。**</span><br><span class="line">    - **学生还有能做的活动，读书、写作、跑步、打篮球等。**</span><br><span class="line">    - **比如一个老师可以教书、批改作业等。**</span><br><span class="line">    - **比如运行员可以参加训练和比赛等。**</span><br><span class="line">- 可以理解为学校就是一个对象</span><br><span class="line"></span><br><span class="line">## 【4】优缺点</span><br><span class="line"></span><br><span class="line">- 优点</span><br><span class="line">  - 解决了程序的扩展性</span><br><span class="line">  - 对某一个对象单独修改，会立刻反映到整个体系中，比如对游戏中的人物和场景进行修改就会很容易，而且是立刻有成效。</span><br><span class="line">- 缺点</span><br><span class="line">  - 编程的复杂度远高于面向过程，不了解面向对象而立即上手基于它设计程序，极容易出现过度设计的问题。</span><br><span class="line">  - 无法向面向过程的程序设计流水线式的可以很精准的预测问题的处理流程与结果，面向对象的程序一旦开始就由对象之间的交互解决问题，即便是上帝也无法准确地预测最终结果。</span><br><span class="line"></span><br><span class="line">## 【5】什么是程序</span><br><span class="line"></span><br><span class="line">- 程序 = 数据 + 功能</span><br><span class="line">- 编写程序的本质就是定义出一系列的数据，然后定义出一系列的功能来对数据进行操作。</span><br><span class="line"></span><br><span class="line"># 【二】类</span><br><span class="line"></span><br><span class="line">## 【1】什么是类</span><br><span class="line"></span><br><span class="line">- 类即类别、种类，是面向对象设计最重要的概念，对象是特征与技能的结合体，而类则是一系列对象相似的特征与技能的结合体</span><br><span class="line"></span><br><span class="line">## 【2】定义类</span><br><span class="line"></span><br><span class="line">- 只能描述共同特性，不同特性要对象自己描述</span><br><span class="line"></span><br><span class="line">- 关键字class声明一个类（先定义了类才有对象）</span><br><span class="line">  - 定义类尽量用驼峰体（例如：User）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```python</span><br><span class="line">#定义类格式有的三种</span><br><span class="line">1：class Student(object)</span><br><span class="line">2：class Student()</span><br><span class="line">3：class Student</span><br><span class="line">#类名后面的 () 参数不写默认就是 object</span><br><span class="line">#定义类的格式</span><br><span class="line">class 类名：</span><br><span class="line">	类体代码</span><br><span class="line">    object:父类</span><br><span class="line">    1：class是定义类的关键字</span><br><span class="line">    2：类名类似于函数名，定义类尽量用驼峰体</span><br><span class="line">    3：类体代码就是存放对象公共数据和功能的地方</span><br><span class="line">    	数据：变量名 = 变量值</span><br><span class="line">        功能：函数</span><br><span class="line">#函数名（）得到的是函数的返回值</span><br><span class="line"># 如果你自己写了那就是你写的，如果没写就是 None</span><br></pre></td></tr></table></figure>

<ul>
<li>调用类的方法</li>
</ul>
```python
#例子
变量名 = 类名（）
print（变量名）#得到的是名称空间字典 例如：<__main__.Student object at 0x000001F2074B1340>
#想用类里面的属性和方法
print(变量名.属性)#前提是已经走了这一步：变量名 = 类名（）
print(student.read())
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 【3】类的属性加扩展属性</span><br><span class="line"></span><br><span class="line">### 【1】扩展属性</span><br><span class="line"></span><br><span class="line">1. 获取当前类的名字</span><br><span class="line">   - 对象名.	`__name__	`</span><br><span class="line">2. 获取类中的文档字符串</span><br><span class="line">   - 对象名.	`__doc__	`</span><br><span class="line">3. 获取类的父类</span><br><span class="line">   - 对象名.	`__base__	`</span><br><span class="line">4. 获取类的所有父类</span><br><span class="line">   - 对象名.	`__bases__	`</span><br><span class="line">5. 获取当前类的名称空间</span><br><span class="line">   - 变量名:		`__dict__	`</span><br><span class="line">6. 获取类定义所在的模块名</span><br><span class="line">   - 变量名：	`__module__	`</span><br><span class="line"></span><br><span class="line">### 【2】类的定义</span><br><span class="line"></span><br><span class="line">- 案例</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```python</span><br><span class="line">class Student(object):</span><br><span class="line">     # 数据属性</span><br><span class="line">     school_name = &quot;清华&quot;</span><br><span class="line"></span><br><span class="line">     # 函数属性</span><br><span class="line">     def read(self):</span><br><span class="line">         age = 18</span><br><span class="line">         # self : 表示对象自己本身，</span><br><span class="line">         print(f&quot;当前学校是 &#123;self.school_name&#125;&quot;)</span><br><span class="line"></span><br><span class="line">student = Student()</span><br><span class="line">print(student)  # &lt;__main__.Student object at 0x000001F2074B1340&gt;</span><br><span class="line"># 想用类里面的属性和方法</span><br><span class="line">print(student.school_name)</span><br><span class="line">print(student.read())  # None</span><br></pre></td></tr></table></figure>

<h3 id="【3】查看类的名称空间">【3】查看类的名称空间</h3>
<h4 id="【1】方法">【1】方法</h4>
<ul>
<li>​	<code>__dict__	</code></li>
<li>类.	<code>__dict__	</code>返回值是一个字典</li>
</ul>
<h4 id="【2】如何产生对象">【2】如何产生对象</h4>
<ul>
<li>类名加括号</li>
</ul>
<h4 id="【3】如何修改对象的属性">【3】如何修改对象的属性</h4>
<ul>
<li>
<p>通过类的名称空间修改属性</p>
</li>
<li>
<p>类的名称空间不允许修改属性</p>
</li>
</ul>
```python
class DreamStudent(object):
    school = '梦想学城'

    def read_books(self):
        print('is reading books')

    def write_nodes(self):
        print('is write nodes')

    def running(self):
        print('is running')


obj1 = DreamStudent()  # 目前对象没有自己独有的属性
obj2 = DreamStudent()  # 目前对象没有自己独有的属性
print(obj1.__dict__)  # 大白话就是给字典添加键值对  {}
print(obj2.__dict__)  # 大白话就是给字典添加键值对  {}
'''方案1:逐步给对象添加独有的数据'''
obj1.__dict__['name'] = 'dream'  # obj1.name = 'dream'
obj1.__dict__['age'] = 18  # obj1.age = 18
obj1.__dict__['gender'] = 'male'  # obj1.gender = 'male'

obj2.__dict__['name'] = 'hope'  # obj2.name = 'hope'
obj2.__dict__['age'] = 2  # obj2.age = 28
obj2.__dict__['gender'] = 'female'  # obj2.gender = 'female'
print(obj1.__dict__,
      obj2.__dict__)  # {'name': 'dream', 'age': 18, 'gender': 'male'} {'name': 'hope', 'age': 2, 'gender': 'female'}
print(obj1.name)  # dream
print(obj2.name)  # hope
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 【4】批量修改属性</span><br><span class="line"></span><br><span class="line">##### （0）修改方法</span><br><span class="line"></span><br><span class="line">- 方式一：通过名称空间字典替换</span><br><span class="line">  - student.	`__dict__	`[&#x27;name&#x27;] = &quot;dream&quot;</span><br><span class="line"></span><br><span class="line">- 方式二：通过对象.属性名=属性值替换</span><br><span class="line"></span><br><span class="line">  - &#123;% raw %&#125;```python</span><br><span class="line">    student_one.name = &#x27;dream&#x27;</span><br><span class="line">    student_one.age = 18</span><br><span class="line">    student_one.gender = &#x27;male&#x27;</span><br><span class="line">    student_two.name = &#x27;opp&#x27;</span><br><span class="line">    student_two.age = 19</span><br><span class="line">    student_two.gender = &#x27;female&#x27;</span><br></pre></td></tr></table></figure>

<h5 id="（1）批量向对象中添加各自独有的属性值和属性名">（1）批量向对象中添加各自独有的属性值和属性名</h5>
<ul>
<li>init_obj(obj=student_one,name=‘dream’,age=18,gender=‘male’)</li>
</ul>
```python
#Student()：类名称
def init_obj(obj,name,age,gender):
    obj.name = name
    obj.age = age
    obj.gender = gender
student_one = Student()
student_two = Student()
init_obj(obj=student_one,name='dream',age=18,gender='male')
init_obj(obj=student_two,name='opp',age=19,gender='female')

print(student_one.name)
print(student_two.name)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### （2）在类内部初始化自己的参数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```python</span><br><span class="line">class Student(object):</span><br><span class="line">    # 数据属性</span><br><span class="line">    school_name = &quot;清华&quot;</span><br><span class="line"></span><br><span class="line">    def init_obj(self, name, age, gender):</span><br><span class="line">        # self 就是这个类的对象本身</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.gender = gender</span><br><span class="line"></span><br><span class="line">    # 函数属性</span><br><span class="line">    def read(self):</span><br><span class="line">        print(f&quot;当前学校是 &#123;self.school_name&#125;&quot;)</span><br><span class="line">        print(f&quot;当前学生姓名是 &#123;self.name&#125;&quot;)</span><br><span class="line">        print(f&quot;当前学生年龄是 &#123;self.age&#125;&quot;)</span><br><span class="line">        print(f&quot;当前学生性别是 &#123;self.gender&#125;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">student = Student()</span><br><span class="line"># &#x27;Student&#x27; object has no attribute &#x27;name&#x27;</span><br><span class="line">student.init_obj(name=&#x27;dream&#x27;,age=18,gender=&#x27;male&#x27;)</span><br><span class="line">student.read()</span><br></pre></td></tr></table></figure>

<h4 id="【5】魔法方法值初始化方法-init">【5】魔法方法值初始化方法		<code>__init__	</code></h4>
<ol>
<li>类中的	<code>__init__	</code>方法会在类产生对象的时候自己执行</li>
<li>类产生对象的具体步骤
<ul>
<li>先创建一个没有独有数据的空对象</li>
<li>将空对象和类括号内传入的数据一并交给<code>__init__</code>
<ul>
<li><code>__init__</code>第一个参数就是对象本身</li>
<li><code>__init__</code>(obj,name,age,gender)</li>
</ul>
</li>
<li>创建好的对象自动返回，给你提供这种方式能够减少代码的编写</li>
</ul>
</li>
<li>针对括号内第一个形参self其实就是一个普通的变量名而已
<ul>
<li>只不过该变量名将来专门接收对象的 所以给它起了个固定的名字叫self</li>
</ul>
</li>
</ol>
```python
#案例
class Student(object):
    # 数据属性
    school_name = "清华"

    def __init__(self, name, age, gender):
        # self 就是这个类的对象本身
        self.name = name
        self.age = age
        self.gender = gender

    # 函数属性
    def read(self):
        print(f"当前学校是 {self.school_name}")
        print(f"当前学生姓名是 {self.name}")
        print(f"当前学生年龄是 {self.age}")
        print(f"当前学生性别是 {self.gender}")

    def write(self):
        print(f"当前学生 :>>> {self.name} 可以写作业!")
        
# 初始化类得到对象
student = Student(name='dream', age=18, gender='male')
print(student.__dict__)
student.read()
student.write()
student_one = Student(name='opp', age=28, gender='female')
student_one.read()
student_one.write() 
```

<h4 id="【6】属性查找顺序">【6】属性查找顺序</h4>
<ul>
<li>
<p>由内向外</p>
<ul>
<li>
<p>首先在自己的对象中查找</p>
</li>
<li>
<p>自己找不到就去父类里面找</p>
</li>
<li>
<p>如果父类里面找不到，就去基类里面找</p>
</li>
<li>
<p>如果基类里面也没有，就去 object 里面找</p>
</li>
<li>
<p>如果还是找不到则报错</p>
</li>
</ul>
</li>
</ul>
<h4 id="【7】对象是可变数据类型">【7】对象是可变数据类型</h4>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aurora-lsk.asia/2025/10/15/5.11%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%B0%81%E8%A3%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="坤">
      <meta itemprop="description" content="选择有时候比努力更重要，但是你不努力，选择就只是空谈">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="坤博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/15/5.11%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%B0%81%E8%A3%85/" class="post-title-link" itemprop="url">5.11面向对象，封装</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-10-15 11:34:55 / 修改时间：16:15:50" itemprop="dateCreated datePublished" datetime="2025-10-15T11:34:55+08:00">2025-10-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Blog/" itemprop="url" rel="index"><span itemprop="name">Blog</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>面向对象</h1>
<h1>【一】面向对象的三大特性</h1>
<ul>
<li>继承</li>
<li>封装
<ul>
<li>封装：就是将数据与功能整和到一起</li>
<li>类里面定义数据和方法的时候，都会有一个需求，某些方法和属性是不能被别人看到的</li>
</ul>
</li>
<li>多态</li>
</ul>
<h1>【二】什么是封装</h1>
<ul>
<li>封装就是对具体对象的一种抽象</li>
<li>就是将某部分的功能和代码隐藏起来，在程序内部看不到，只能在程序内部使用</li>
<li>封装最主要的<strong>原因</strong>就是保护隐私，将不想让用户看到的功能都隐藏起来</li>
<li><code>**封装的意思就像是隐私，你想让他会看到的就让他看到，不想让它看到的就隐藏起来**</code></li>
</ul>
<h1>【三】封装隐藏属性</h1>
<h2 id="【1】在变量名前面加">【1】在变量名前面加__</h2>
<ul>
<li>例子:先定义一个类，然后在里面写函数，不想让用户看到的就在变量名前加__</li>
</ul>
```python
class Student():
    #在变量名前加__：初始化对象的时候就会将变量名进行变形，变形成
    #_Student__SCHOOL_NAME:就是变成，_类名__变量名
    __SCHOOL_NAME="清华"
    
    def __init__(self,name):
        self.name = name
        
student = Student(name="dream")
#得到名字
print(student.__dict__)#{'name': 'dream'}
#对参数值进行修改
student.name = "opp"
print(student.name)#opp
#查看名称空间
print(student.__dict__)#{'name': 'opp'}
# print(Student.__SCHOOL_NAME)#找不到报错:类型对象'Student'没有属性'_SCHOOL_NAME'
print(Student._Student__SCHOOL_NAME)#清华
print(Student.__dict__)#在里面能找到这个：'_Student__SCHOOL_NAME': '清华'
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 【2】函数属性</span><br><span class="line"></span><br><span class="line">- `__dict__`:查询函数属性，得到的是个字典</span><br><span class="line">- `__init__`:魔法方法--》也称为初始化方法，用于初始化对象状态，用的时候随时调用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```python</span><br><span class="line">class Person:</span><br><span class="line">    SCHOOL_NAME = &quot;清华&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    def __change_name(self):</span><br><span class="line">        self.name = &quot;nb_&quot; + self.name</span><br><span class="line">        print(&quot;进来了&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">student = Person(name=&quot;tom&quot;)</span><br><span class="line">print(student)#&lt;__main__.Person object at 0x0000026C87D5FFD0&gt;</span><br><span class="line"></span><br><span class="line">print(student.__dict__)#&#123;&#x27;name&#x27;: &#x27;tom&#x27;&#125;</span><br><span class="line"></span><br><span class="line">print(student.__init__)#&lt;bound method Person.__init__ of &lt;__main__.Person object at 0x0000026C87D5FFD0&gt;&gt;</span><br><span class="line"></span><br><span class="line">print(Person.__dict__)#里面有很多属性就列举了一个：&#123; &#x27;SCHOOL_NAME&#x27;: &#x27;清华&#x27;&#125;</span><br><span class="line"></span><br><span class="line">print(Person)#&lt;class &#x27;__main__.Person&#x27;&gt;</span><br><span class="line"></span><br><span class="line">print(person._Person__change_name())#不带前缀_Person会报错，表示找不到</span><br><span class="line">#进来了</span><br><span class="line">#没有返回值所以同时返回了：None</span><br></pre></td></tr></table></figure>

<h2 id="【3】什么是初始化过程">【3】什么是初始化过程</h2>
```python
class Person:  
    def __init__(self, name, age):  
        self.name = name  
        self.age = age  
  
# 创建一个新的Person对象  
person1 = Person("Alice", 30)  
  
# 此时，person1 对象已经有了 name 和 age 属性  
print(person1.name)  # 输出: Alice  
print(person1.age)   # 输出: 30
在这个例子中，当您调用 Person("Alice", 30) 时，Python 创建了一个新的 Person 对象，并调用了 Person 类的 __init__ 方法来设置该对象的 name 和 age 属性。这就是我们通常所说的“变形”或“初始化”过程。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 【4】补充</span><br><span class="line"></span><br><span class="line">- 变形只会发生一次</span><br><span class="line">- 变形只会发生在初始化的时候</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```python</span><br><span class="line">class Person:</span><br><span class="line">    __SCHOOL_NAME = &quot;清华&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">student = Person()</span><br><span class="line"># print(student.__SCHOOL_NAME)#会报错</span><br><span class="line">student.__SCHOOL_NAME = &#x27;北大&#x27;</span><br><span class="line">print(student.__SCHOOL_NAME)#北大</span><br><span class="line">print(Person.__dict__)#&#123;&#x27;_Person__SCHOOL_NAME&#x27;: &#x27;清华&#x27;&#125;</span><br><span class="line">print(student.__dict__)#&#123;&#x27;__SCHOOL_NAME&#x27;: &#x27;北大&#x27;&#125;</span><br><span class="line"></span><br><span class="line">#这两个不是一个东西：print(Person.__dict__)和print(student.__dict__)</span><br><span class="line">#student.__SCHOOL_NAME = &#x27;北大&#x27;：只是加到了student属性里面</span><br></pre></td></tr></table></figure>

<h1>【四】什么是开放接口</h1>
<ul>
<li>
<p>定义属性，隐藏属是为了不让用户看到对应的功能和逻辑</p>
</li>
<li>
<p>但是我们要给用户对应的修改接口</p>
</li>
</ul>
```python
class Teacher:
    def __init__(self, name, age):
        # 将名字和年纪都隐藏起来
        self.__name = name
        self.__age = age

    # 对外提供访问老师信息的接口
    def tell_info(self):
        print('姓名:%s,年龄:%s' % (self.__name, self.__age))

    # 对外提供设置老师信息的接口，并附加类型检查的逻辑
    def set_info(self, name, age):
        if not isinstance(name, str):
            raise TypeError('姓名必须是字符串类型')
        if not isinstance(age, int):
            raise TypeError('年龄必须是整型')
        self.__name = name
        self.__age = age


# 实例化类得到对象
teacher = Teacher("dream", 18)
# 代用对象中的方法，修改对象的信息
# age 必须是数字类型，但是给了字符串，所以一定会报错
teacher.set_info('hope', '22')
#报错信息：r'''
Traceback (most recent call last):
  File "E:\PythonProjects\10面向对象\02封装.py", line 140, in <module>
    teacher.set_info('hope', '22')
  File "E:\PythonProjects\10面向对象\02封装.py", line 131, in set_info
    raise TypeError('年龄必须是整型')
TypeError: 年龄必须是整型
'''
``````

<p>python</p>
<h1>调用对象的方法修改对象的信息 , 符合要求就能修改成功</h1>
<p>teacher.set_info(‘Hope’, 22)</p>
<h1>查看对象的信息</h1>
<p>teacher.tell_info()</p>
<h1>姓名:Hope,年龄:22</h1>
```





- 总结
  - 总结隐藏属性与开放接口，本质就是为了明确地区分内外，类内部可以修改封装内的东西而不影响外部调用者的代码；
  - 而类外部只需拿到一个接口，只要接口名、参数不变，则无论设计者如何改变内部实现代码，使用者均无需改变代码。
  - 这就提供一个良好的合作基础，只要接口这个基础约定不变，则代码的修改不足为虑。

# 【五】装饰器property拓展

- property是一种特殊的属性，将函数的返回值作为数据属性返回



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line">python</span><br><span class="line">class Student:</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def vip_name(self):</span><br><span class="line">        return self.name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">student = Student(name=&#x27;dream&#x27;)</span><br><span class="line">print(student.name)</span><br><span class="line"># 不加property之前</span><br><span class="line"># print(student.vip_name)  # &lt;bound method Student.vip_name of &lt;__main__.Student object at 0x000001F2944AB190&gt;&gt;</span><br><span class="line"># print(student.vip_name())  # dream</span><br><span class="line"># 加了property之后</span><br><span class="line">print(student.vip_name)  # dream</span><br><span class="line">print(student.vip_name())  # 加了property之后，后面就不能有（），有就会报错</span><br><span class="line">&#123;% raw %&#125;```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 【1】BIM例子</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>python</p>
<h1>BMI ： 衡量一个人的体重和身高对健康影响的指标</h1>
<h1>指标</h1>
<h1>○ 过轻：低于18.5</h1>
<h1>○ 正常：18.5-23.9</h1>
<h1>○ 过重：24-27</h1>
<h1>○ 肥胖：28-32</h1>
<h1>○ 非常肥胖, 高于32</h1>
<h1>计算公式</h1>
<h1>○ 体质指数（BMI）=体重（kg）÷身高^2（m）</h1>
<h1>○ EX：70kg÷（1.75×1.75）=22.86</h1>
``````python
class BMI:
    def __init__(self, name, weight, height):
        self.name = name
        self.weight = weight
        self.height = height

    @property
    def bmi(self):
        return self.weight / (self.height ** 2)


dream = BMI(name='dream', weight=64, height=1.7)

print(dream.bmi)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 【2】为什么使用property</span><br><span class="line"></span><br><span class="line">- 在编程语言中有三种封装方式</span><br><span class="line">  - public：不封装,是对外公开的</span><br><span class="line">  - protected:对外不公开，对内公开</span><br><span class="line">  - private:对谁用不公开</span><br><span class="line"></span><br><span class="line">### （1）方法一</span><br><span class="line"></span><br><span class="line">- 在使用property之后</span><br><span class="line">  - 修改 ：@函数名.setter，要在修改的函数头上，就像用装饰器那样</span><br><span class="line">  - 删除：@函数名.deleter，要在修改的函数头上，就像用装饰器那样</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```python</span><br><span class="line">#例题</span><br><span class="line">class Person(object):</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.__name = name</span><br><span class="line"></span><br><span class="line">    # 给当前函数名添加装饰器 property</span><br><span class="line">    # 将当前 函数名作为一个数据属性返回</span><br><span class="line">    @property</span><br><span class="line">    def vip_name(self):</span><br><span class="line">        # 返回值可以是字符串也可以是其他内容</span><br><span class="line">        return self.__name</span><br><span class="line"></span><br><span class="line">    # 修改 和 property 包装的函数名一致 并且加 .setter</span><br><span class="line">    # 修改当前变量民的时候会触发</span><br><span class="line">    @vip_name.setter</span><br><span class="line">    def vip_name(self, value):</span><br><span class="line">        print(value)</span><br><span class="line">        self.__name = value</span><br><span class="line">    </span><br><span class="line">    # 删除  和 property 包装的函数名一致 并且加 .deleter</span><br><span class="line">    # 删除当前变量民的时候会触发</span><br><span class="line">    @vip_name.deleter</span><br><span class="line">    def vip_name(self):</span><br><span class="line">        del self.__name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">person = Person(name=&#x27;dream&#x27;)</span><br><span class="line"># 查看</span><br><span class="line">print(person.vip_name)</span><br><span class="line"># &lt;bound method Person.name of &lt;__main__.Person object at 0x000001EE86C22340&gt;&gt;</span><br><span class="line"></span><br><span class="line"># 修改</span><br><span class="line">person.vip_name = &#x27;opp&#x27;</span><br><span class="line">print(person.vip_name)</span><br><span class="line"></span><br><span class="line"># 删除</span><br><span class="line"># del person.vip_name</span><br><span class="line"># print(person.vip_name)</span><br></pre></td></tr></table></figure>

<h3 id="（2）方法二">（2）方法二</h3>
<ul>
<li>使用包装的形式</li>
<li>区别就在于，它在最后，包所有函数名进行了包装
<ul>
<li><code>vip_name = property(get_vip_name, set_vip_name, del_vip_name)</code></li>
</ul>
</li>
</ul>
```python
class Person(object):
    def __init__(self, name):
        self.__name = name

    # 给当前函数名添加装饰器 property
    # 将当前 函数名作为一个数据属性返回
    def get_vip_name(self):
        # 返回值可以是字符串也可以是其他内容
        return self.__name

    # 修改 和 property 包装的函数名一致 并且加 .setter
    # 修改当前变量民的时候会触发
    def set_vip_name(self, value):
        print(value)
        self.__name = value

    # 删除  和 property 包装的函数名一致 并且加 .deleter
    # 删除当前变量民的时候会触发
    def del_vip_name(self):
        del self.__name

    vip_name = property(get_vip_name, set_vip_name, del_vip_name)

person = Person(name='dream')
# 查看
print(person.vip_name)
# <bound method Person.name of <__main__.Person object at 0x000001EE86C22340>>

# 修改
person.vip_name = 'opp'
print(person.vip_name)

# 删除
del person.vip_name
print(person.vip_name)
```


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aurora-lsk.asia/2025/10/15/5.0MySQL%E4%B9%8B%E8%BF%87%E6%BB%A4%E6%9D%A1%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="坤">
      <meta itemprop="description" content="选择有时候比努力更重要，但是你不努力，选择就只是空谈">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="坤博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/15/5.0MySQL%E4%B9%8B%E8%BF%87%E6%BB%A4%E6%9D%A1%E4%BB%B6/" class="post-title-link" itemprop="url">5.0MySQL之过滤条件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-10-15 11:34:55 / 修改时间：16:15:50" itemprop="dateCreated datePublished" datetime="2025-10-15T11:34:55+08:00">2025-10-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Blog/" itemprop="url" rel="index"><span itemprop="name">Blog</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>MySQL之过滤条件</h1>
<h2 id="【一】过滤条件语法查询">【一】过滤条件语法查询</h2>
```sql
select */字段名 from 表名 where 筛选的条件;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- *代表所有的内容，也可以换成其他内容</span><br><span class="line">- 查找的顺序</span><br><span class="line">  - from --》确定在那个表</span><br><span class="line">  - where --》确定一下是什么条件，在表中过滤</span><br><span class="line">  - select--》过滤出自己想要的数据</span><br><span class="line"></span><br><span class="line">## 【二】数据准备</span><br><span class="line"></span><br><span class="line">### 【1】创建库</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```sql</span><br><span class="line">-- 先判断表是否存在，存在删除，不存在什么都不发生</span><br><span class="line">drop table if exists emp;</span><br><span class="line"></span><br><span class="line">-- 创建库</span><br><span class="line">create database emp;</span><br></pre></td></tr></table></figure>

<p><img src="D:%5Cpycharm%5CTemporary_notes%5C%E5%9B%BE%E7%89%87%5Cimage-20240530095357395.png" alt="image-20240530095357395"></p>
<h3 id="【2】创建表">【2】创建表</h3>
```sql
-- 切换到库
use data;

-- 创建表
create table emp(
id int not null unique auto_increment,
    name varchar(20) not null,
    sex enum("male","female") not null default "male",
    age int(3) unsigned not null default 28,
    hire_date date not null,
    post varchar(50),
    post_comment varchar(100),
    salary double(15,2),
    office int,
    depart_id int
);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20240530095411650](D:\pycharm\Temporary_notes\图片\image-20240530095411650.png)</span><br><span class="line"></span><br><span class="line">### 【3】查看表结构</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```sql</span><br><span class="line">desc emp;</span><br></pre></td></tr></table></figure>

<p><img src="D:%5Cpycharm%5CTemporary_notes%5C%E5%9B%BE%E7%89%87%5Cimage-20240530095434612.png" alt="image-20240530095434612"></p>
<h3 id="【4】插入数据">【4】插入数据</h3>
```sql
insert into emp(name, sex, age, hire_date, post, salary, office, depart_id) values
("dream", "male", 78, '20220306', "陌夜痴梦久生情", 730.33, 401, 1), # 以下是教学部
("mengmeng", "female", 25, '20220102', "teacher", 12000.50, 401, 1),
("xiaomeng", "male", 35, '20190607', "teacher", 15000.99, 401, 1),
("xiaona", "female", 29, '20180906', "teacher", 11000.80, 401, 1),
("xiaoqi", "female", 27, '20220806', "teacher", 13000.70, 401, 1),
("suimeng", "male", 33, '20230306', "teacher", 14000.62, 401, 1), # 以下是销售部
("娜娜", "female", 69, '20100307', "sale", 300.13, 402, 2),
("芳芳", "male", 45, '20140518', "sale", 400.45, 402, 2),
("小明", "male", 34, '20160103', "sale", 350.80, 402, 2),
("亚洲", "female", 42, '20170227', "sale", 320.99, 402, 2),
("华华", "female", 55, '20180319', "sale", 380.75, 402, 2),
("田七", "male", 44, '20230808', "sale", 420.33, 402, 2), # 以下是运行部
("大古", "female", 66, '20180509', "operation", 630.33, 403, 3),
("张三", "male", 51, '20191001', "operation", 410.25, 403, 3),
("李四", "male", 47, '20200512', "operation", 330.62, 403, 3),
("王五", "female", 39, '20210203', "operation", 370.98, 403, 3),
("赵六", "female", 36, '20220724', "operation", 390.15, 403, 3);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20240530095451586](D:\pycharm\Temporary_notes\图片\image-20240530095451586.png)</span><br><span class="line"></span><br><span class="line">### 【5】查看插入的数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```sql</span><br><span class="line">select * from emp;</span><br></pre></td></tr></table></figure>

<p><img src="D:%5Cpycharm%5CTemporary_notes%5C%E5%9B%BE%E7%89%87%5Cimage-20240530095504090.png" alt="image-20240530095504090"></p>
<h3 id="【6】格式化美化数据">【6】格式化美化数据</h3>
```sql
selcet * from emp\G;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20240530095523427](D:\pycharm\Temporary_notes\图片\image-20240530095523427.png)</span><br><span class="line"></span><br><span class="line">## 【三】筛选条件where</span><br><span class="line"></span><br><span class="line">### 【1】作用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```sql</span><br><span class="line">select * from * where *;</span><br><span class="line">-- 先走where 在走select</span><br></pre></td></tr></table></figure>

<ul>
<li>对整体的数据进行筛选</li>
</ul>
<h3 id="【2】查询3-id-6的数据">【2】查询3&lt;=id&lt;=6的数据</h3>
<ul>
<li>用到查询条件 and（和）</li>
</ul>
```sql
select id,name,age from emp where id>=3 and id<=6;

select id,name,age from emp where id between 3 and 6;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20240530100403340](D:\pycharm\Temporary_notes\图片\image-20240530100403340.png)</span><br><span class="line"></span><br><span class="line">![image-20240530100557236](D:\pycharm\Temporary_notes\图片\image-20240530100557236.png)</span><br><span class="line"></span><br><span class="line">### 【3】查看薪水的1w2或者1w3或者730的数据</span><br><span class="line"></span><br><span class="line">- 用到查询条件in，or</span><br><span class="line">- in</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```sql</span><br><span class="line">select * from emp where salary in (12000.50,13000.70,730.33);</span><br></pre></td></tr></table></figure>

<p><img src="D:%5Cpycharm%5CTemporary_notes%5C%E5%9B%BE%E7%89%87%5Cimage-20240530111453047.png" alt="image-20240530111453047"></p>
<ul>
<li>or</li>
</ul>
```sql
select * from emp where salary=12000.50 or salary = 13000.70 or salary = 730.33;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20240530111606807](D:\pycharm\Temporary_notes\图片\image-20240530111606807.png)</span><br><span class="line"></span><br><span class="line">### 【4】查询员工姓名中包含字母o的姓名和薪资</span><br><span class="line"></span><br><span class="line">- 用到模糊查询：like</span><br><span class="line">- %任意字符</span><br><span class="line">- _一个字符</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```sql</span><br><span class="line">select name,salary from emp where name like &#x27;%o%&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="D:%5Cpycharm%5CTemporary_notes%5C%E5%9B%BE%E7%89%87%5Cimage-20240530112051038.png" alt="image-20240530112051038"></p>
<h3 id="【5】查询数据指定别名">【5】查询数据指定别名</h3>
<ul>
<li>在字段名后面： as ‘别名’</li>
<li>比如：查询员工姓名中包含字母o的姓名和薪资</li>
</ul>
```sql
select name as '员工名字',salary as '薪资' from emp where name like '%o%';
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20240530112553024](D:\pycharm\Temporary_notes\图片\image-20240530112553024.png)</span><br><span class="line"></span><br><span class="line">### 【6】查询员工是由六个字符组成的姓名和薪资(char_length)</span><br><span class="line"></span><br><span class="line">- 模糊查询 ：like &#x27;______&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```sql</span><br><span class="line">select name as &#x27;员工名字&#x27;,salary as &#x27;薪资&#x27; from emp where name like &#x27;______&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="D:%5Cpycharm%5CTemporary_notes%5C%E5%9B%BE%E7%89%87%5Cimage-20240530112841285.png" alt="image-20240530112841285"></p>
<ul>
<li>char_length : 查询长度</li>
</ul>
```sql
select name as '员工名字',salary as '薪资' from emp where char_length(name)=6;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20240530113056326](D:\pycharm\Temporary_notes\图片\image-20240530113056326.png)</span><br><span class="line"></span><br><span class="line">### 【7】查询 id&lt;3 或者 id&gt;6 的数据</span><br><span class="line"></span><br><span class="line">- 用到关键字 ： between ：之间的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```sql</span><br><span class="line">select * from emp where id not between 3 and 6; </span><br></pre></td></tr></table></figure>

<p><img src="D:%5Cpycharm%5CTemporary_notes%5C%E5%9B%BE%E7%89%87%5Cimage-20240530143459090.png" alt="image-20240530143459090"></p>
<h3 id="【8】查询岗位描述为空的员工名和岗位名">【8】查询岗位描述为空的员工名和岗位名</h3>
<ul>
<li>针对null不能用=，要用is</li>
<li>=</li>
</ul>
```sql
select name as '员工名',post as '部门' from emp where post_comment=null;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20240530143911735](D:\pycharm\Temporary_notes\图片\image-20240530143911735.png)</span><br><span class="line"></span><br><span class="line">- is</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```sql</span><br><span class="line">select name as &#x27;员工名&#x27;,post as &#x27;部门&#x27; from emp where post_comment is null;</span><br></pre></td></tr></table></figure>

<p><img src="D:%5Cpycharm%5CTemporary_notes%5C%E5%9B%BE%E7%89%87%5Cimage-20240530144008079.png" alt="image-20240530144008079"></p>
<h2 id="【四】筛选条件group-by-分组">【四】筛选条件group by(分组)</h2>
```sql
-- 语法
select * from * group by *;
-- 结合where
select * from * where * group by *;
-- group by 后面跟时通过那个字段进行分组
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 【1】什么时候需要分组，分组的目的</span><br><span class="line"></span><br><span class="line">- 关键字：最高，最低，平均，每个</span><br><span class="line">- 目的：为了对分组内的数据进行处理</span><br><span class="line"></span><br><span class="line">### 【2】聚合函数</span><br><span class="line"></span><br><span class="line">- min ：最小值</span><br><span class="line">- max ：最大值</span><br><span class="line">- avg : 平均值</span><br><span class="line">- count : 计数</span><br><span class="line">- sun ：总和值</span><br><span class="line">- group_concat: 获得分组之后的具体值</span><br><span class="line">- concat : 查询数据，不分组也可以用</span><br><span class="line"></span><br><span class="line">### 【3】按照部门对所有员工进行分组，修改严格模式</span><br><span class="line"></span><br><span class="line">- 查询数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```sql</span><br><span class="line">select * from emp group by post;</span><br><span class="line"></span><br><span class="line">-- 报错</span><br></pre></td></tr></table></figure>

<p><img src="D:%5Cpycharm%5CTemporary_notes%5C%E5%9B%BE%E7%89%87%5Cimage-20240530145033685.png" alt="image-20240530145033685"></p>
<ul>
<li>解决办法
<ul>
<li>修改严格模式</li>
</ul>
</li>
</ul>
```sql
-- 查看严格模式--》用模糊查询
show variables like '%mode%';
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 删除严格模式--》ONLY_FULL_GROUP_BY</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```sql</span><br><span class="line">set global sql_mode = &#x27;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#x27;;</span><br></pre></td></tr></table></figure>

<ul>
<li>退出客户端重新进入</li>
</ul>
```sql
select * from emp group by post;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20240530145722489](D:\pycharm\Temporary_notes\图片\image-20240530145722489.png)</span><br><span class="line"></span><br><span class="line">- 查询数据--》设置严格模式后，按照什么分组就只能拿到什么</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```sql</span><br><span class="line">select post from emp group by post;</span><br></pre></td></tr></table></figure>

<p><img src="D:%5Cpycharm%5CTemporary_notes%5C%E5%9B%BE%E7%89%87%5Cimage-20240530150012195.png" alt="image-20240530150012195"></p>
<h3 id="【4】获取每个部门的最高薪资">【4】获取每个部门的最高薪资</h3>
<ul>
<li>用到了聚合函数 max
<ul>
<li>取最大值</li>
</ul>
</li>
<li>要看全部信息：把<code>post as '部门',max(salary) as '最高薪资'</code>换成*就好。</li>
</ul>
```sql
select post as '部门',max(salary) as '最高薪资' from emp group by post;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20240530151402555](D:\pycharm\Temporary_notes\图片\image-20240530151402555.png)</span><br><span class="line"></span><br><span class="line">### 【5】获取每个部门的最低薪资</span><br><span class="line"></span><br><span class="line">- 用到了聚合函数min</span><br><span class="line">  - 取最小值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```sql</span><br><span class="line">select post as &#x27;部门&#x27;,min(salary) as &#x27;最低薪资&#x27; from emp group by post;</span><br></pre></td></tr></table></figure>

<p><img src="D:%5Cpycharm%5CTemporary_notes%5C%E5%9B%BE%E7%89%87%5Cimage-20240530151630258.png" alt="image-20240530151630258"></p>
<h3 id="【6】获取每个部门的平均薪资">【6】获取每个部门的平均薪资</h3>
<ul>
<li>用到了聚合函数的avg
<ul>
<li>获得平均薪资</li>
</ul>
</li>
</ul>
```sql
select post as '部门',avg(salary) as '平均薪资' from emp group by post;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20240530152102132](D:\pycharm\Temporary_notes\图片\image-20240530152102132.png)</span><br><span class="line"></span><br><span class="line">### 【7】获得每个部门的工资总和</span><br><span class="line"></span><br><span class="line">- 用到了聚合函数sum</span><br><span class="line">  - 总和</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```sql</span><br><span class="line">select post as &#x27;部门&#x27;,sum(salary) as &#x27;薪资综和&#x27; from emp group by post;</span><br></pre></td></tr></table></figure>

<p><img src="D:%5Cpycharm%5CTemporary_notes%5C%E5%9B%BE%E7%89%87%5Cimage-20240530152911725.png" alt="image-20240530152911725"></p>
<h3 id="【8】获取每各部门的人数">【8】获取每各部门的人数</h3>
<ul>
<li>用到了聚合函数count
<ul>
<li>计数</li>
</ul>
</li>
</ul>
```sql
-- 也可与根据年龄和id 进行查询，不能对null计数
select post as '部门',count(salary) as '部门人数' from emp group by post; 
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20240530153230636](D:\pycharm\Temporary_notes\图片\image-20240530153230636.png)</span><br><span class="line"></span><br><span class="line">- null--》count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```sql</span><br><span class="line">select post as &#x27;部门&#x27;,count(post_comment) as &#x27;部门人数&#x27; from emp group by post; </span><br></pre></td></tr></table></figure>

<p><img src="D:%5Cpycharm%5CTemporary_notes%5C%E5%9B%BE%E7%89%87%5Cimage-20240530153532560.png" alt="image-20240530153532560"></p>
<h3 id="【9】查询分组之后的部门名称和每个部门下所有的员工姓名-group-concat">【9】查询分组之后的部门名称和每个部门下所有的员工姓名(group_concat)</h3>
<h4 id="（1）查询数据">（1）查询数据</h4>
<ul>
<li>用到了聚合函数：group_concat
<ul>
<li>获得分组之后的具体的值</li>
<li>还支持拼接操作</li>
</ul>
</li>
</ul>
```sql
select post as '部门',group_concat(name) as '员工名字' from emp group by post;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20240530154905731](D:\pycharm\Temporary_notes\图片\image-20240530154905731.png)</span><br><span class="line"></span><br><span class="line">#### （2）拼接数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```sql</span><br><span class="line">select post as &#x27;部门&#x27;,group_concat(name,&#x27;_nb&#x27;) as &#x27;拼接的员工名字&#x27; from emp group by post;</span><br></pre></td></tr></table></figure>

<p><img src="D:%5Cpycharm%5CTemporary_notes%5C%E5%9B%BE%E7%89%87%5Cimage-20240530155128256.png" alt="image-20240530155128256"></p>
<h4 id="（3）还可以添加多个字段进行拼接-查询">（3）还可以添加多个字段进行拼接 查询</h4>
```sql
select post as '部门',group_concat(name,'_nb','&',salary) as '拼接的员工名字和薪资' from emp group by post;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20240530155312713](D:\pycharm\Temporary_notes\图片\image-20240530155312713.png)</span><br><span class="line"></span><br><span class="line">#### （4）查询数据--》不分组之前用concat</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```sql</span><br><span class="line">select concat(name) as &#x27;名字&#x27;,concat(age) as &#x27;年龄&#x27; from emp;</span><br></pre></td></tr></table></figure>

<p><img src="D:%5Cpycharm%5CTemporary_notes%5C%E5%9B%BE%E7%89%87%5Cimage-20240530155630066.png" alt="image-20240530155630066"></p>
<h4 id="（5）as语句–》临时改表名">（5）as语句–》临时改表名</h4>
<ul>
<li>还可以给表改名字–》只是临时的</li>
</ul>
```sql
select id,name from emp;

select emp.id,emp.name from emp;

-- 两个结果是一样的
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20240530160107792](D:\pycharm\Temporary_notes\图片\image-20240530160107792.png)</span><br><span class="line"></span><br><span class="line">- 改表名</span><br><span class="line">  - 改的时候也要把字段名前的表名一起改了</span><br><span class="line">  - 不一起改的话就会报错</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```sql</span><br><span class="line">select new_emp.id,new_emp.name from emp as new_emp;</span><br></pre></td></tr></table></figure>

<p><img src="D:%5Cpycharm%5CTemporary_notes%5C%E5%9B%BE%E7%89%87%5Cimage-20240530160414823.png" alt="image-20240530160414823"></p>
<p>【10】查询每个人的年薪</p>
```sql
select name as '名字',salary*12 as '年薪' from emp;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20240530160636311](D:\pycharm\Temporary_notes\图片\image-20240530160636311.png)</span><br><span class="line"></span><br><span class="line">### 【11】筛选条件group by(分组)的注意点</span><br><span class="line"></span><br><span class="line">- 关键字where和group by同时出现时</span><br><span class="line">  - where先对整条数据进行过滤</span><br><span class="line">  - group by在对数据进行分组</span><br><span class="line">- where不能使用聚合函数</span><br><span class="line">  - 不分组，一张表就是一组</span><br><span class="line">  - 用了就会报错</span><br><span class="line">- 集合函数只能在分组之后使用</span><br><span class="line"></span><br><span class="line">#### （1）统计各部门年龄在 30 岁以上的员工的平均薪资</span><br><span class="line"></span><br><span class="line">- 先过滤数据的到岁以上数据的员工信息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```sql</span><br><span class="line">select * from emp where age &gt; 30;</span><br></pre></td></tr></table></figure>

<p><img src="D:%5Cpycharm%5CTemporary_notes%5C%E5%9B%BE%E7%89%87%5Cimage-20240530161306202.png" alt="image-20240530161306202"></p>
<ul>
<li>在进行分组得到部门</li>
</ul>
```sql
select * from emp where age > 30 group by post;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20240530161609582](D:\pycharm\Temporary_notes\图片\image-20240530161609582.png)</span><br><span class="line"></span><br><span class="line">- 将两个数据结合</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```sql</span><br><span class="line">select post as &#x27;部门&#x27;,avg(salary) as &#x27;平均薪资&#x27; from emp where age &gt; 30 group by post;</span><br></pre></td></tr></table></figure>

<p><img src="D:%5Cpycharm%5CTemporary_notes%5C%E5%9B%BE%E7%89%87%5Cimage-20240530161835153.png" alt="image-20240530161835153"></p>
<h2 id="【五】筛选条件之having-分组之后筛选">【五】筛选条件之having(分组之后筛选)</h2>
<h3 id="【1】介绍">【1】介绍</h3>
<ul>
<li>having和where两个功能一样
<ul>
<li>一个是where是在分组前进行筛选</li>
<li>一个是having是在分组后进行筛选</li>
</ul>
</li>
<li>having可以直接使用聚合函数</li>
</ul>
<h3 id="【2】统计各部门年龄在-30-岁以上的员工的工资，并且保留平均薪资大于1w的部门">【2】统计各部门年龄在 30 岁以上的员工的工资，并且保留平均薪资大于1w的部门</h3>
<ul>
<li>分析：where 30年龄以上的员工</li>
<li>group by 分组 port 平均薪资</li>
<li>having 大于1w的部门</li>
</ul>
```sql
-- where
select * from emp where age>30;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20240530163057513](D:\pycharm\Temporary_notes\图片\image-20240530163057513.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```sql</span><br><span class="line">-- group by</span><br><span class="line">select post,salary from emp group by post;</span><br></pre></td></tr></table></figure>

<p><img src="D:%5Cpycharm%5CTemporary_notes%5C%E5%9B%BE%E7%89%87%5Cimage-20240530163119615.png" alt="image-20240530163119615"></p>
```sql
-- 结合 where，group by，having
select post,avg(salary) from emp 
where age>30  
group by post 
having avg(salary)>10000;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20240530163138931](D:\pycharm\Temporary_notes\图片\image-20240530163138931.png)</span><br><span class="line"></span><br><span class="line">- 还可以给字段名改名字</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```sql</span><br><span class="line">-- 针对聚合函数 如果还需要在其他地方作为条件使用 可以先起别名</span><br><span class="line">select post,avg(salary) as avg_salary from emp </span><br><span class="line">  where age&gt;30 </span><br><span class="line">  group by post</span><br><span class="line">  having avg_salary &gt; 10000</span><br><span class="line">  ;</span><br></pre></td></tr></table></figure>

<p><img src="D:%5Cpycharm%5CTemporary_notes%5C%E5%9B%BE%E7%89%87%5Cimage-20240530163310356.png" alt="image-20240530163310356"></p>
<h2 id="【六】筛选条件之distinct-去重">【六】筛选条件之distinct(去重)</h2>
<ul>
<li>
<p>distinct ： 去除重复的</p>
</li>
<li>
<p>数据完全一样才可以去重</p>
</li>
<li>
<p>一定义要注意主键</p>
<ul>
<li>主键存在是一定不可能重复的</li>
<li>所以有主键用distinct无效</li>
</ul>
</li>
</ul>
<h3 id="【1】对表emp中的age和id去重">【1】对表emp中的age和id去重</h3>
<ul>
<li>id是主键约束，不可能重复</li>
</ul>
```sql
select distinct id,age from emp;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20240530163818036](D:\pycharm\Temporary_notes\图片\image-20240530163818036.png)</span><br><span class="line"></span><br><span class="line">### 【2】对表emp中的age去重</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```sql</span><br><span class="line">select distinct age from emp;</span><br></pre></td></tr></table></figure>

<p><img src="D:%5Cpycharm%5CTemporary_notes%5C%E5%9B%BE%E7%89%87%5Cimage-20240530163921431.png" alt="image-20240530163921431"></p>
<h2 id="【七】筛选条件之order-by-排序">【七】筛选条件之order by(排序)</h2>
<ul>
<li>order by : 默认是升序</li>
<li>asc 默认是修改升序，可省略不写</li>
<li>desc 降序</li>
</ul>
<h3 id="【1】将表emp按照薪资排序–-升序">【1】将表emp按照薪资排序–&gt;升序</h3>
```sql
select * from emp order by salary;

select * from emp order by salary asc;

-- 两个数据一样
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20240530164347160](D:\pycharm\Temporary_notes\图片\image-20240530164347160.png)</span><br><span class="line"></span><br><span class="line">### 【2】将表emp按照薪资排序--&gt;降序</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```sql</span><br><span class="line">select * from emp order by salary desc;</span><br></pre></td></tr></table></figure>

<p><img src="D:%5Cpycharm%5CTemporary_notes%5C%E5%9B%BE%E7%89%87%5Cimage-20240530164500012.png" alt="image-20240530164500012"></p>
<h3 id="【3】将emp表中的数据按照日期-升序-和性别-降序-排序">【3】将emp表中的数据按照日期(升序)和性别(降序)排序</h3>
<ul>
<li>方法：order by 后面可以跟多个参数</li>
</ul>
```sql
select  * from emp order by sex asc,hire_date desc;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20240530165230838](D:\pycharm\Temporary_notes\图片\image-20240530165230838.png)</span><br><span class="line"></span><br><span class="line">### 【4】混合排序</span><br><span class="line"></span><br><span class="line">统计各部门年龄在 10 岁以上的员工的工资，并且保留平均薪资大于1000的部门，对平均工资进行排序</span><br><span class="line"></span><br><span class="line">- 统计各部门年龄在 10 岁以上的员工</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```sql</span><br><span class="line">-- where</span><br><span class="line">select * from emp where age&gt;10;</span><br></pre></td></tr></table></figure>

<p><img src="D:%5Cpycharm%5CTemporary_notes%5C%E5%9B%BE%E7%89%87%5Cimage-20240530165437907.png" alt="image-20240530165437907"></p>
<ul>
<li>统计各部门年龄在 10 岁以上的员工的工资</li>
</ul>
```sql
select name,salary from emp where age>10 group by salary;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20240530165641048](D:\pycharm\Temporary_notes\图片\image-20240530165641048.png)</span><br><span class="line"></span><br><span class="line">- 统计各部门年龄在 10 岁以上的员工的工资，并且保留平均薪资大于100的部门</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```sql</span><br><span class="line">select post,avg(salary) from emp </span><br><span class="line">where age&gt;10 </span><br><span class="line">group by post</span><br><span class="line">having avg(salary)&gt;100;</span><br></pre></td></tr></table></figure>

<p><img src="D:%5Cpycharm%5CTemporary_notes%5C%E5%9B%BE%E7%89%87%5Cimage-20240530170150864.png" alt="image-20240530170150864"></p>
<ul>
<li>统计各部门年龄在 10 岁以上的员工的工资，并且保留平均薪资大于1000的部门，对平均工资进行排序</li>
</ul>
```sql
select post,avg(salary) from emp 
where age>10 
group by post
having avg(salary)>100
order by avg(salary) desc;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20240530170157695](D:\pycharm\Temporary_notes\图片\image-20240530170157695.png)</span><br><span class="line"></span><br><span class="line">## 【八】筛选条件之limit（限制展示条数）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```sql</span><br><span class="line">select * from * where * limit stare_index,number;</span><br></pre></td></tr></table></figure>

<ul>
<li>
<p>limit ：限制展示的条数</p>
</li>
<li>
<p>第一个参数是o索引位置，第二个是打印的条数</p>
</li>
</ul>
<h3 id="【1】查询数据：单个数字">【1】查询数据：单个数字</h3>
<ul>
<li>单个数字就是其实索引位置就是0+1，从零开始，打印打印10条</li>
</ul>
```sql
select * from emp limit 10;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20240530170452839](D:\pycharm\Temporary_notes\图片\image-20240530170452839.png)</span><br><span class="line"></span><br><span class="line">### 【2】查询数据：多限制</span><br><span class="line"></span><br><span class="line">- 0，6：---》从0+1的位置开始打印，打印6条</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```sql</span><br><span class="line">select * from emp limit 0,6;</span><br></pre></td></tr></table></figure>

<p><img src="D:%5Cpycharm%5CTemporary_notes%5C%E5%9B%BE%E7%89%87%5Cimage-20240530170724503.png" alt="image-20240530170724503"></p>
<h3 id="【3】查询工资最高的人的详细信息">【3】查询工资最高的人的详细信息</h3>
<ul>
<li>升序–》在打印</li>
</ul>
```sql
select * from emp order by salary limit 1;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20240530170952254](D:\pycharm\Temporary_notes\图片\image-20240530170952254.png)</span><br><span class="line"></span><br><span class="line">## 【九】筛选条件之正则</span><br><span class="line"></span><br><span class="line">- 定义正则表必须字母打字</span><br><span class="line"></span><br><span class="line">### 【1】语法</span><br><span class="line"></span><br><span class="line">- 属性名 ：查询的字段名称</span><br><span class="line">- 匹配方式 ：哪种方式来匹配查询</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```sql</span><br><span class="line">属性名 REGEXP &#x27;匹配方式&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="【2】匹配方式">【2】匹配方式</h3>
<ul>
<li>“匹配方式”中有很多的模式匹配字符，它们分别表示不同的意思。</li>
<li>下表列出了 REGEXP 操作符中常用的匹配方式。</li>
</ul>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>例子</th>
<th>匹配值示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>匹配文本的开始字符</td>
<td>‘^b’ 匹配以字母 b 开头的字符串</td>
<td>book、big、banana、bike</td>
</tr>
<tr>
<td>$</td>
<td>匹配文本的结束字符</td>
<td>‘st$’ 匹配以 st 结尾的字符串</td>
<td>test、resist、persist</td>
</tr>
<tr>
<td>.</td>
<td>匹配任何单个字符</td>
<td>‘b.t’ 匹配任何 b 和 t 之间有一个字符</td>
<td>bit、bat、but、bite</td>
</tr>
<tr>
<td>*</td>
<td>匹配前面的字符 0 次或多次</td>
<td>‘f*n’ 匹配字符 n 前面有任意个字符 f</td>
<td>fn、fan、faan、abcn</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的字符 1 次或多次</td>
<td>‘ba+’ 匹配以 b 开头，后面至少紧跟一个 a</td>
<td>ba、bay、bare、battle</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面的字符 0 次或1次</td>
<td>‘sa?’ 匹配0个或1个a字符</td>
<td>sa、s</td>
</tr>
<tr>
<td>字符串</td>
<td>匹配包含指定字符的文本</td>
<td>‘fa’ 匹配包含‘fa’的文本</td>
<td>fan、afa、faad</td>
</tr>
<tr>
<td>[字符集合]</td>
<td>匹配字符集合中的任何一个字符</td>
<td>‘[xz]’ 匹配 x 或者 z</td>
<td>dizzy、zebra、x-ray、extra</td>
</tr>
<tr>
<td>[^]</td>
<td>匹配不在括号中的任何字符</td>
<td>‘[^abc]’ 匹配任何不包含 a、b 或 c 的字符串</td>
<td>desk、fox、f8ke</td>
</tr>
<tr>
<td>字符串{n,}</td>
<td>匹配前面的字符串至少 n 次</td>
<td>‘b{2}’ 匹配 2 个或更多的 b</td>
<td>bbb、bbbb、bbbbbbb</td>
</tr>
<tr>
<td>字符串{n,m}</td>
<td>匹配前面的字符串至少 n 次， 至多 m 次</td>
<td>‘b{2,4}’ 匹配最少 2 个，最多 4 个 b</td>
<td>bbb、bbbb</td>
</tr>
</tbody>
</table>
<h3 id="【3】案例">【3】案例</h3>
<ul>
<li>创建一个表</li>
</ul>
```sql
DROP TABLE IF EXISTS `person`;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 创建表</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```sql</span><br><span class="line">CREATE TABLE `person`  (</span><br><span class="line">  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `age` int(40) NULL DEFAULT NULL,</span><br><span class="line">  `heigh` int(40) NULL DEFAULT NULL,</span><br><span class="line">  `sex` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL</span><br><span class="line">) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;</span><br></pre></td></tr></table></figure>

<p><img src="D:%5Cpycharm%5CTemporary_notes%5C%E5%9B%BE%E7%89%87%5Cimage-20240530171758235.png" alt="image-20240530171758235"></p>
<ul>
<li>插入数据</li>
</ul>
```sql
INSERT INTO `person` VALUES ('Thomas ', 25, 168, '男');
INSERT INTO `person` VALUES ('Tom ', 20, 172, '男');
INSERT INTO `person` VALUES ('Dany', 29, 175, '男');
INSERT INTO `person` VALUES ('Jane', 27, 171, '男');
INSERT INTO `person` VALUES ('Susan', 24, 173, '女');
INSERT INTO `person` VALUES ('Green', 25, 168, '女');
INSERT INTO `person` VALUES ('Henry', 21, 160, '女');
INSERT INTO `person` VALUES ('Lily', 18, 190, '男');
INSERT INTO `person` VALUES ('LiMing', 19, 187, '男');
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20240530171816521](D:\pycharm\Temporary_notes\图片\image-20240530171816521.png)</span><br><span class="line"></span><br><span class="line">- 查看数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;````sql</span><br><span class="line">select * from person:</span><br><span class="line">````</span><br><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20240530171918210](D:\pycharm\Temporary_notes\图片\image-20240530171918210.png)</span><br><span class="line"></span><br><span class="line">#### (1)查询 name 字段以j开头的记录</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```sql</span><br><span class="line">select * from person where name REGEXP&#x27;^j&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="D:%5Cpycharm%5CTemporary_notes%5C%E5%9B%BE%E7%89%87%5Cimage-20240530172103202.png" alt="image-20240530172103202"></p>
<h4 id="（2）查询-name-字段以“y”结尾的记录">（2）查询 name 字段以“y”结尾的记录</h4>
```sql
select * from person where name REGEXP'y$';
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20240530172240305](D:\pycharm\Temporary_notes\图片\image-20240530172240305.png)</span><br><span class="line"></span><br><span class="line">#### (3)查询 name 字段值包含“a”和“y”，且两个字母之间只有一个字母的记录</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```sql</span><br><span class="line">select * from person where name REGEXP&#x27;a.y&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="D:%5Cpycharm%5CTemporary_notes%5C%E5%9B%BE%E7%89%87%5Cimage-20240530172353608.png" alt="image-20240530172353608"></p>
<h4 id="4-查询-name-字段值包含字母“T”，且“T”后面出现字母“h”的记录">(4)查询 name 字段值包含字母“T”，且“T”后面出现字母“h”的记录</h4>
<ul>
<li>不区分大小写</li>
</ul>
```sql
select * from person where name REGEXP'Th*';
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20240530172729607](D:\pycharm\Temporary_notes\图片\image-20240530172729607.png)</span><br><span class="line"></span><br><span class="line">#### (5)查询 name 字段值包含字母“T”，且“T”后面至少出现“h”一次的记录</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```sql</span><br><span class="line">select * from person where name REGEXP&#x27;Th+&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="D:%5Cpycharm%5CTemporary_notes%5C%E5%9B%BE%E7%89%87%5Cimage-20240530173051856.png" alt="image-20240530173051856"></p>
<h4 id="6-查询-name-字段值包含字母“S”，且“S”后面出现“a”一次或零次的记录">(6)查询 name 字段值包含字母“S”，且“S”后面出现“a”一次或零次的记录</h4>
```SQL
select * from person where name REGEXP'Sa?';
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20240530173903011](D:\pycharm\Temporary_notes\图片\image-20240530173903011.png)</span><br><span class="line"></span><br><span class="line">#### (7)查询 name 字段值包含字符串“an”的记录</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```sql</span><br><span class="line">select * from person where name REGEXP&#x27;an&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="D:%5Cpycharm%5CTemporary_notes%5C%E5%9B%BE%E7%89%87%5Cimage-20240530174046847.png" alt="image-20240530174046847"></p>
<h4 id="8-查询-name-字段值包含字符串“an”或“en”的记录">(8)查询 name 字段值包含字符串“an”或“en”的记录</h4>
<ul>
<li>指定多个字符串时，需要用|隔开。只要匹配这些字符串中的任意一个即可。</li>
</ul>
```sql
select * from person where name REGEXP'an|en';
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20240530174202281](D:\pycharm\Temporary_notes\图片\image-20240530174202281.png)</span><br><span class="line"></span><br><span class="line">#### (9)查询 name 字段值包含字母“i”或“o”的记录</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### （10）方括号[ ]还可以指定集合的区间。</span><br><span class="line"></span><br><span class="line">- 例如，“[a-z]”表示从 a~z 的所有字母；</span><br><span class="line">- “[0-9]”表示从 0~9 的所有数字；</span><br><span class="line">- “[a-z0-9]”表示包含所有的小写字母和数字；</span><br><span class="line">- “[a-zA-Z]”表示匹配所有字符。</span><br><span class="line">- MySQL中的正则表达式匹配不区分大小写。</span><br><span class="line">- 为区分大小写，可使用BINARY关键字。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```sql</span><br><span class="line">select * from person where name REGEXP BINARY&#x27;^[a-z]&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="D:%5Cpycharm%5CTemporary_notes%5C%E5%9B%BE%E7%89%87%5Cimage-20240530174448579.png" alt="image-20240530174448579"></p>
<h4 id="11-查询-name-字段值包含字母-a-t-以外的字符的记录">(11)查询 name 字段值包含字母 a~t 以外的字符的记录</h4>
```sql
select * from person where name REGEXP   '[^a-t]';
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20240530174556290](D:\pycharm\Temporary_notes\图片\image-20240530174556290.png)</span><br><span class="line"></span><br><span class="line">#### (12)查询name字段值出现字母‘e’至少两次的记录</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```sql</span><br><span class="line">select * from person where name REGEXP  &#x27;e&#123;2,&#125;&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="D:%5Cpycharm%5CTemporary_notes%5C%E5%9B%BE%E7%89%87%5Cimage-20240530174707893.png" alt="image-20240530174707893"></p>
<h4 id="13-查询-name-字段值出现字符串“i”-最少-1-次，最多-3-次的记录">(13)查询 name 字段值出现字符串“i” 最少 1 次，最多 3 次的记录</h4>
```sql
select * from person where name REGEXP'i{1,3}';
```

<p><img src="D:%5Cpycharm%5CTemporary_notes%5C%E5%9B%BE%E7%89%87%5Cimage-20240530174819609.png" alt="image-20240530174819609"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aurora-lsk.asia/2025/10/15/5.17%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%8F%8D%E5%B0%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="坤">
      <meta itemprop="description" content="选择有时候比努力更重要，但是你不努力，选择就只是空谈">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="坤博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/15/5.17%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%8F%8D%E5%B0%84/" class="post-title-link" itemprop="url">5.17面向对象，反射</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-10-15 11:34:55 / 修改时间：16:15:50" itemprop="dateCreated datePublished" datetime="2025-10-15T11:34:55+08:00">2025-10-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Blog/" itemprop="url" rel="index"><span itemprop="name">Blog</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>反射</h1>
<h2 id="【一】什么是反射">【一】什么是反射</h2>
<ul>
<li>
<p>反射是一种程序访问检测和修改本身属性和状态的方式</p>
</li>
<li>
<p>在Python内也有反射机制，通过字符串映射自己的内部是否具有某种属性</p>
</li>
<li>
<p><strong>python中的一切事物都是对象（都可以使用反射）</strong></p>
</li>
</ul>
<h2 id="【二】python中的四个方法">【二】python中的四个方法</h2>
<ul>
<li>获取属性
<ul>
<li><code>getattr(obj,key)</code></li>
</ul>
</li>
<li>判断当前属性是否存在
<ul>
<li><code>hasattr(obj,key)</code></li>
</ul>
</li>
<li>向当前对象中设置属性名和属性值
<ul>
<li><code>setattr(obj,key,value)</code></li>
</ul>
</li>
<li>删除对象中的指定属性
<ul>
<li><code>delattr(obj,key)</code></li>
</ul>
</li>
</ul>
<h2 id="【三】四种方式的具体使用方法">【三】四种方式的具体使用方法</h2>
<h3 id="（1）获取属性getattr-obj-key">（1）获取属性<code>getattr(obj,key)</code></h3>
<ul>
<li>数据属性
<ul>
<li>在对象中映射数据属性的时候，如果对象中存在当前属性值则直接将属性值拿出来</li>
</ul>
</li>
</ul>
```python
class Person(object):
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def tell(self):
        print(f'{self.name} is {self.age} years old')

    @classmethod
    def talk(cls):
        print(cls.__name__)

    @staticmethod
    def swim():
        print(f'I am a swimming')

people = Person(name='dream', age=18)
result = getattr(people,"name")
print(result)#dream
result = getattr(people,'age')
print(result)#18
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 函数属性</span><br><span class="line">  - 在对象中映射函数属性的时候，如果对象中存在当前属性名对应的数据属性,则直接获取当前函数属性的内存地址，可以直接调用当前函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```python</span><br><span class="line">result = getattr(people,&#x27;tell&#x27;)</span><br><span class="line">print(result)#&lt;bound method Person.tell of &lt;__main__.Person object at 0x000001C2C4F172B0&gt;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>在对象中映射属性的时候，如果对象中不存在当前属性名对应的属性，会直接报错</li>
</ul>
<h3 id="2-判断当前属性是否存在hasattr-obj-key-–-返回布尔类型">(2)判断当前属性是否存在<code>hasattr(obj,key)</code>*–&gt;返回布尔类型</h3>
<ul>
<li>数据属性</li>
</ul>
```python
class Person(object):
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def tell(self):
        print(f'{self.name} is {self.age} years old')

    @classmethod
    def talk(cls):
        print(cls.__name__)

    @staticmethod
    def swim():
        print(f'I am a swimming')

people = Person(name='dream', age=18)
result = hasattr(people,"name")
print(result)#True
result = hasattr(people,'age')
print(result)#True
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 函数属性</span><br><span class="line">  - 在对象中映射函数属性的时候，如果对象中存在当前属性名对应的数据属性，则返回True</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```python</span><br><span class="line">people = Person(name=&#x27;dream&#x27;, age=18)</span><br><span class="line">result = hasattr(people,&#x27;tell&#x27;)</span><br><span class="line">print(result)#True</span><br></pre></td></tr></table></figure>

<ul>
<li>在对象中映射属性的时候，如果对象中不存在当前属性名对应的属性，则返回False</li>
</ul>
<h3 id="（3）向当前对象中设置属性值和属性名setattr-obj-key-value">（3）向当前对象中设置属性值和属性名<code>setattr(obj,key,value)</code></h3>
<ul>
<li>数据属性
<ul>
<li>向对象中设置属性名和属性值，如果对象中存在当前属性则直接替换，否则新增</li>
</ul>
</li>
</ul>
```python
people = Person(name='dream', age=18)
result = setattr(people,"gender","male")
print(result)#None
print(people.gender)#male
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 函数属性</span><br><span class="line">  - 在对象中映射函数属性的时候，如果对象中存在当前属性名对应的数据属性，则返回True</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```python</span><br><span class="line">def read():</span><br><span class="line">     print(f&quot;这是外部的 read &quot;)</span><br><span class="line">def onr():</span><br><span class="line">    print(f&quot;,,,,&quot;)</span><br><span class="line"></span><br><span class="line">people = Person(name=&#x27;dream&#x27;, age=18)</span><br><span class="line">#设置进去的方法叫非静态方法</span><br><span class="line">result = setattr(people,&quot;read&quot;,onr)</span><br><span class="line">print(result)#None</span><br><span class="line">print(hasattr(people, &#x27;read&#x27;))  # True</span><br><span class="line">print(getattr(people, &#x27;read&#x27;))  # &lt;function onr at 0x0000022CA5A6AEF0&gt;</span><br><span class="line">getattr(people,&quot;read&quot;)()#,,,,</span><br></pre></td></tr></table></figure>

<h3 id="（4）删除对象中的指定属性delattr-obj-key">（4）删除对象中的指定属性<code>delattr(obj,key)</code></h3>
<ul>
<li>数据属性
<ul>
<li>在对象中删除数据属性的时候，如果对象中存在当前属性值则直接删除</li>
</ul>
</li>
</ul>
```python
people = Person(name='dream', age=18)
print(hasattr(people,'name')) # True
result = delattr(people,'name')
print(result) # None
print(hasattr(people,'name')) # False
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 函数属性</span><br><span class="line">  - 在对象中删除函数属性的时候，要根据参数是对象还是类来做区分</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```python</span><br><span class="line"># print(hasattr(Person, &#x27;tell&#x27;))  # True</span><br><span class="line"># 如果参数是当前对象，则无法删除函数属性</span><br><span class="line"># result = delattr(people, &#x27;tell&#x27;)</span><br><span class="line"># result = delattr(people, &#x27;talk&#x27;)</span><br><span class="line"># result = delattr(people, &#x27;swim&#x27;)</span><br><span class="line"># 如果参数是当前类，则可以删除函数属性</span><br><span class="line"># result = delattr(Person, &#x27;tell&#x27;) #</span><br><span class="line"># result = delattr(Person, &#x27;talk&#x27;)</span><br><span class="line"># result = delattr(Person, &#x27;swim&#x27;)</span><br><span class="line"># print(result)  # None</span><br><span class="line"># print(hasattr(Person, &#x27;swim&#x27;))</span><br></pre></td></tr></table></figure>

<ul>
<li>在对象中删除属性的时候，如果对象中不存在当前属性名对应的属性，则直接报错</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aurora-lsk.asia/2025/10/15/5.12%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%8C%E7%BB%A7%E6%89%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="坤">
      <meta itemprop="description" content="选择有时候比努力更重要，但是你不努力，选择就只是空谈">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="坤博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/15/5.12%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%8C%E7%BB%A7%E6%89%BF/" class="post-title-link" itemprop="url">5.12面向对象，继承</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-10-15 11:34:55 / 修改时间：16:15:50" itemprop="dateCreated datePublished" datetime="2025-10-15T11:34:55+08:00">2025-10-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Blog/" itemprop="url" rel="index"><span itemprop="name">Blog</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>继承</h1>
<h2 id="【一】介绍">【一】介绍</h2>
<h3 id="【1】什么是继承">【1】什么是继承</h3>
<ul>
<li>继承就是创建新类的方式，新建的类可以继承一个或多个类的属性</li>
<li>新的类如果有自己的属性，就叫派生</li>
</ul>
<h3 id="【2】优点">【2】优点</h3>
<ul>
<li>可以继承父类的所有的属性和方法，实现代码的去重</li>
</ul>
<h3 id="【3】继承的方式">【3】继承的方式</h3>
<ul>
<li>
<p>两种方式</p>
<ul>
<li>
<p>单继承：继承一个父类的子类</p>
</li>
<li>
```python
    class Person(object):
        height = 188
        weight = 66
        
    #继承一个父类的所有属性
    class Student(Person):
        def __init__(self, name):
            self.name = name
        def tell_me(self):
            print(self.height)
            print(self.weight)
            print(self.name)
            
    student = Student(name="tom")
    student.tell_me()
    # 188
    # 66
    # tom
    
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  - 多继承：继承多个父类的子类(两个父类以上)</span><br><span class="line"></span><br><span class="line">    &#123;% raw %&#125;```python</span><br><span class="line">    class Person(object):</span><br><span class="line">        height = 188</span><br><span class="line">        weight = 66</span><br><span class="line">        </span><br><span class="line">    class School(object):</span><br><span class="line">        school = &quot;家里蹲大学&quot;</span><br><span class="line">        </span><br><span class="line">    class Student(Person, School):</span><br><span class="line">        def __init__(self, name):</span><br><span class="line">            self.name = name</span><br><span class="line">        def tell_me(self):</span><br><span class="line">            print(self.height)</span><br><span class="line">            print(self.weight)</span><br><span class="line">            print(self.name)</span><br><span class="line">            print(self.school)</span><br><span class="line">            </span><br><span class="line">    student = Student(name=&quot;tom&quot;)</span><br><span class="line">    student.tell_me()</span><br><span class="line">    # 188</span><br><span class="line">    # 66</span><br><span class="line">    # tom</span><br><span class="line">    #家里蹲大学</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
<li>
<p>例子：</p>
</li>
</ul>
```python
class Student(School):
#新建的类叫子类：Student
#继承的类叫父类：School
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 【4】如何查看继承的父类</span><br><span class="line"></span><br><span class="line">#### （1）查看当前的父类（`__base__`）</span><br><span class="line"></span><br><span class="line">- 如果类名括号里有多个父类，默认打印第一个</span><br><span class="line"></span><br><span class="line">#### （2）查看当前继承的父类们（`__bases__`）</span><br><span class="line"></span><br><span class="line">- 得到的是一个元组，元组中继承的是搜有的父类</span><br><span class="line"></span><br><span class="line">## 【二】经典类和新式类</span><br><span class="line"></span><br><span class="line">- 经典类和新式类的区别就在于python版本的区别</span><br><span class="line">- 在python3之前存在这两个概念，之后就不存在与经典类概念了，只有新式类</span><br><span class="line"></span><br><span class="line">### 【1】什么是经典类</span><br><span class="line"></span><br><span class="line">- 在python3之前没有显示继承object的类就叫经典类</span><br><span class="line">  - 意思就是：类名后面（）没有定义--》都叫经典类</span><br><span class="line"></span><br><span class="line">### 【2】什么是新式类</span><br><span class="line"></span><br><span class="line">- 在python3之后没有显示继承的类，默认都是新式类，默认继承object</span><br><span class="line"></span><br><span class="line">## 【三】继承和抽象（抽象在继承下）</span><br><span class="line"></span><br><span class="line">- 继承是子类与父类之间的关系</span><br><span class="line">- 必须先抽象在继承</span><br><span class="line">- 抽象：抽取类似的或者比较像的部分</span><br><span class="line"></span><br><span class="line">### 【1】抽象</span><br><span class="line"></span><br><span class="line">- 讲不同的类，根据指定的表征总结起来归介于一个类</span><br><span class="line">  - 意思就是从多个类中抽取类似的部分，总结到一个类里面</span><br><span class="line"></span><br><span class="line">### 【2】继承</span><br><span class="line"></span><br><span class="line">- 基于抽象的结果，然后用语言去实现</span><br><span class="line">  - 用抽象，来实现语法</span><br><span class="line"></span><br><span class="line">### 【3】继承，抽象</span><br><span class="line"></span><br><span class="line">- 继承是由少变多</span><br><span class="line"></span><br><span class="line">- 抽象是由多变小</span><br><span class="line"></span><br><span class="line">- ### 没有抽象和继承</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```python</span><br><span class="line">class Cat(object):</span><br><span class="line">    def speak(self):</span><br><span class="line">        print(f&quot;猫可以喵喵叫&quot;)</span><br><span class="line"></span><br><span class="line">    def eat(self):</span><br><span class="line">        print(&quot;猫可以吃饭&quot;)</span><br><span class="line"></span><br><span class="line">    def drink(self):</span><br><span class="line">        print(&quot;猫可以喝水&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 有一只狗</span><br><span class="line">class Dog(object):</span><br><span class="line">    def speak(self):</span><br><span class="line">        print(f&quot;狗可以旺旺叫&quot;)</span><br><span class="line"></span><br><span class="line">    def eat(self):</span><br><span class="line">        print(&quot;狗可以吃饭&quot;)</span><br><span class="line"></span><br><span class="line">    def drink(self):</span><br><span class="line">        print(&quot;狗可以喝水&quot;)</span><br></pre></td></tr></table></figure>

<ul>
<li>
<h3 id="抽象">抽象</h3>
</li>
</ul>
```python
#总结一个公共的类
class Animal(object):
    def speak(self):
        print(f"{self.name}可以叫")

    def eat(self):
        print(f"{self.name}可以吃饭")

    def drink(self):
        print(f"{self.name}可以喝水")

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- ### 继承---&gt;直接用抽象定义的公共类</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```python</span><br><span class="line"># 有一只猫</span><br><span class="line">class Cat(Animal):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = &#x27;猫&#x27;+name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 有一只狗</span><br><span class="line">class Dog(Animal):</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = &#x27;狗&#x27;+name</span><br><span class="line"></span><br><span class="line">cat_one = Cat(name=&#x27;小花&#x27;)</span><br><span class="line">print(cat_one.speak())</span><br><span class="line">dog_one = Dog(name=&quot;旺财&quot;)</span><br><span class="line">print(dog_one.speak())</span><br></pre></td></tr></table></figure>

<h2 id="【四】封装和继承的属性查找顺序">【四】封装和继承的属性查找顺序</h2>
<h3 id="【1】没有封装之前查找属性的顺序">【1】没有封装之前查找属性的顺序</h3>
```python
class Foo:
    def f1(self):
        print('Foo.f1')

    # 【四】在父类 Foo 里面找到了 f2
    def f2(self):
        # 【五】打印 Foo.f2
        print('Foo.f2')
        self.f1()#【六】这里的f1是Bar里面的f1，因为f2（self）：self是Bar。哪个对象调用方法，self 就是谁


class Bar(Foo):
    # 【七】因为是 通过Bar实例化得到的对象，所以 self 就是 Bar
    def f1(self):
        # 【八】打印 Bar.f1
        print('Bar.f1')
    # 【三】Bar里面没有f2，去父类找 Foo


# 【一】类实例化得到对象
b = Bar()
# 【二】对象调用方法 f2
b.f2()
#Foo.f2
#Bar.f1
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 【2】有封装的时候的继承</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```python</span><br><span class="line">class Foo:</span><br><span class="line">    # __f1 --&gt; _Foo__f1</span><br><span class="line">    def __f1(self):</span><br><span class="line">        print(&#x27;Foo.f1&#x27;)</span><br><span class="line"></span><br><span class="line">    # 【4】在Foo里面找到了 f2</span><br><span class="line">    def f2(self):</span><br><span class="line">        # 【5】打印 Foo.f2</span><br><span class="line">        print(&#x27;Foo.f2&#x27;)</span><br><span class="line">        # 【6】没有变形的时候 self 是谁就去谁里面找</span><br><span class="line">        # 但是变形之后 就只能在自己的类里面找，没办跳到别的类里面</span><br><span class="line">        # Foo.f1 2</span><br><span class="line">        # Bar.f1 3</span><br><span class="line">        self.__f1()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Bar(Foo):</span><br><span class="line">    # 【3】没有f2. 去 Foo</span><br><span class="line">    def __f1(self):</span><br><span class="line">        print(&#x27;Bar.f1&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 【1】</span><br><span class="line">b = Bar()</span><br><span class="line"># 【2】</span><br><span class="line">b.f2()</span><br><span class="line">#Foo.f2</span><br><span class="line">#Foo.f1</span><br></pre></td></tr></table></figure>

<h3 id="【3】总结">【3】总结</h3>
<ul>
<li>如果属性不封装的情况下，谁实例化得到的self就去谁里面找</li>
<li>如果属性封装的情况下 ， 谁实例化得到的self 无效，只能在当前所在的类的民称空间里面找</li>
</ul>
<h2 id="【五】菱形继承-》继承实现的原理">【五】菱形继承-----》继承实现的原理</h2>
<ul>
<li>
<p>菱形继承问题，一个类可以继承多个父类，父类又可以继承父类</p>
</li>
<li>
<p>如果继承关系为菱形结构，那么属性的查找方式有两种，分别是：分为深度优先和广度优先</p>
</li>
</ul>
<h3 id="【1】深度优先">【1】深度优先</h3>
<ul>
<li>发生在经典类上，在当前类内部找不到指定属性的时候会想上找</li>
<li>查找规则就是深度优先</li>
<li>一条线找到黑</li>
<li>当类是经典类时，多继承情况下，在查找属性不存在时，会按照深度优先的方式查找下去</li>
</ul>
<h3 id="【2】广度优先">【2】广度优先</h3>
<ul>
<li>
<p>发生在新式类上，在当前内部找不到指定属性的收会想上找</p>
</li>
<li>
<p>查找顺序就是广度优先</p>
</li>
<li>
<p>当类是新式类时，多继承情况下，在查找属性不存在时，会按照广度优先的方式查找下去</p>
</li>
</ul>
<h3 id="【3】例题">【3】例题</h3>
<ul>
<li><code>__mro__</code>查找所有的类里面的函数名
<ul>
<li><code>(&lt;class '__main__.F'&gt;, &lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.E'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;)</code></li>
</ul>
</li>
</ul>
```python
class A(object):
    def test(self):
        print('from A')


class B(A):
    def test(self):
        print('from B')


class C(A):
    def test(self):
        print('from C')


class D(B):
    def test(self):
        print('from D')


class E(C):
    def test(self):
        print('from E')


class F(D, E):
    # def test(self):
    #     print('from F')
    pass


f1 = F()
f1.test()#from D
# 只有新式才有这个属性可以查看线性列表，经典类没有这个属性
print(F.__mro__)#(<class '__main__.F'>, <class '__main__.D'>, <class '__main__.B'>, <class '__main__.E'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>)

# 深度优先：新式类继承顺序:F->D->B->E->C->A
# 广度优先：经典类继承顺序:F->D->B->A->E->C
# python3中统一都是新式类
# pyhon2中才分新式类与经典类
```


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aurora-lsk.asia/2025/10/15/5.13%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%8C%E6%B4%BE%E7%94%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="坤">
      <meta itemprop="description" content="选择有时候比努力更重要，但是你不努力，选择就只是空谈">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="坤博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/15/5.13%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%8C%E6%B4%BE%E7%94%9F/" class="post-title-link" itemprop="url">5.13面向对象，派生</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-10-15 11:34:55 / 修改时间：16:15:50" itemprop="dateCreated datePublished" datetime="2025-10-15T11:34:55+08:00">2025-10-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Blog/" itemprop="url" rel="index"><span itemprop="name">Blog</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>派生</h1>
<h2 id="【一】什么是派生">【一】什么是派生</h2>
<ul>
<li>派生就是<strong>子类继承父类所有的属性和方法，并且派生出自己的属性与方法</strong></li>
</ul>
<h3 id="【1】子类继承父类的属性">【1】子类继承父类的属性</h3>
```python
class People:
    school = '清华大学'

    def __init__(self, name, sex, age):
        self.name = name
        self.sex = sex
        self.age = age


class Teacher(People):
    # 派生 ： 派生出自己新的属性，在进行属性查找时，子类中的属性名会优先于父类被查找
    def __init__(self, name, sex, age, title):
        self.name = name
        self.sex = sex
        self.age = age
        self.title = title

    def teach(self):
        print('%s is teaching' % self.name)


# 只会找自己类中的__init__，并不会自动调用父类的
obj = Teacher('dream', 'male', 18, '高级讲师')
obj.teach()#dream is teaching
print(obj.name, obj.sex, obj.age, obj.title,obj.school)#dream male 18 高级讲师
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 【2】继承方法一</span><br><span class="line"></span><br><span class="line">- 用的时候直接用类名调用函数方法</span><br><span class="line">  -  `People.__init__(self, name, age, sex)`</span><br><span class="line">  - 直接调用就可以用这个函数的属性和方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```python</span><br><span class="line">class People:</span><br><span class="line">    school = &#x27;清华大学&#x27;</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, sex, age):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.sex = sex</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Teacher(People):</span><br><span class="line">    # 派生 ： 派生出自己新的属性，在进行属性查找时，子类中的属性名会优先于父类被查找</span><br><span class="line">    def __init__(self, name, sex, age, title):</span><br><span class="line">        # 直接调用 父类 中 的 __init__ 方法</span><br><span class="line">        # 调用的是函数,因而需要传入self</span><br><span class="line">        People.__init__(self, name, age, sex)</span><br><span class="line">        self.title = title</span><br><span class="line"></span><br><span class="line">    def teach(self):</span><br><span class="line">        print(&#x27;%s is teaching&#x27; % self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 只会找自己类中的__init__，并不会自动调用父类的</span><br><span class="line">obj = Teacher(&#x27;dream&#x27;, &#x27;male&#x27;, 18, &#x27;高级讲师&#x27;)</span><br><span class="line"></span><br><span class="line">print(obj.name, obj.sex, obj.age, obj.title)</span><br><span class="line"># dream male 18 高级讲师</span><br></pre></td></tr></table></figure>

<h3 id="【3】继承方法二">【3】继承方法二</h3>
<ul>
<li>调用**super()**会得到一个特殊的对象</li>
<li>该对象专门用来引用父类的属性</li>
<li>且严格按照MRO规定的顺序向后查找</li>
<li>MRO:查看继承的顺序</li>
</ul>
```python
class People:
    school = '清华大学'

    def __init__(self, name, sex, age):
        self.name = name
        self.sex = sex
        self.age = age


class Teacher(People):
    # 派生 ： 派生出自己新的属性，在进行属性查找时，子类中的属性名会优先于父类被查找
    def __init__(self, name, sex, age, title):
        # 直接调用 父类 中 的 __init__ 方法
        # 调用的是绑定方法，因此会自动传入self,但是需要传入相应的参数
        super().__init__(name, sex, age)
        self.title = title

    def teach(self):
        print('%s is teaching' % self.name)


# 只会找自己类中的__init__，并不会自动调用父类的
obj = Teacher('dream', 'male', 18, '高级讲师')

print(obj.name, obj.sex, obj.age, obj.title)
# dream male 18 高级讲师
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 优缺点：super()，只会拿类名（）里面的第一个父类的属性和方法</span><br><span class="line"></span><br><span class="line">### 【4】总结</span><br><span class="line"></span><br><span class="line">- 这两种方式的区别是：</span><br><span class="line">  - 方式一是跟继承没有关系的，而方式二的super()是依赖于继承的</span><br><span class="line">  - 并且即使没有直接继承关系，super()仍然会按照MRO继续往后查找</span><br><span class="line"></span><br><span class="line">### 【5】组合</span><br><span class="line"></span><br><span class="line">-  在一个类中**以另外一个类的对象作为数据属性**，称为类的组合。</span><br><span class="line">  - 有所有父类的属性和方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```python</span><br><span class="line">class Course:</span><br><span class="line">    def __init__(self, name, period, price):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.period = period</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    def tell_info(self):</span><br><span class="line">        print(f&#x27;当前课程名字 &#123;self.name&#125; 当前课程周期 &#123;self.period&#125; 当前课程价格 &#123;self.price&#125;&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Date:</span><br><span class="line">    def __init__(self, year, mon, day):</span><br><span class="line">        self.year = year</span><br><span class="line">        self.mon = mon</span><br><span class="line">        self.day = day</span><br><span class="line"></span><br><span class="line">    def tell_birth(self):</span><br><span class="line">        print(f&#x27;当前生日 &#123;self.year&#125; 年 &#123;self.mon&#125; 月 &#123;self.day&#125; 日&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class People:</span><br><span class="line">    school = &#x27;清华大学&#x27;</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, sex, age):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.sex = sex</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Teacher类基于继承来重用People的代码</span><br><span class="line"># 基于组合来重用Date类和Course类的代码</span><br><span class="line">class Teacher(People):</span><br><span class="line">    # 老师是人</span><br><span class="line">    def __init__(self, name, sex, age, title, year, mon, day):</span><br><span class="line">        super().__init__(name, age, sex)</span><br><span class="line">        # 老师有生日</span><br><span class="line">        self.birth = Date(year, mon, day)</span><br><span class="line">        # 老师有课程，可以在实例化后，往该列表中添加Course类的对象</span><br><span class="line">        self.courses = []</span><br><span class="line"></span><br><span class="line">    def teach(self):</span><br><span class="line">        print(f&#x27;当前老师正在授课 &#123;self.name&#125;&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">python = Course(&#x27;python&#x27;, &#x27;3mons&#x27;, 3000.0)</span><br><span class="line">linux = Course(&#x27;linux&#x27;, &#x27;5mons&#x27;, 5000.0)</span><br><span class="line">teacher1 = Teacher(&#x27;dream&#x27;, &#x27;male&#x27;, 18, &#x27;金牌讲师&#x27;, 1987, 3, 23)</span><br><span class="line"></span><br><span class="line"># teacher1有两门课程</span><br><span class="line">teacher1.courses.append(python)</span><br><span class="line">teacher1.courses.append(linux)</span><br><span class="line"></span><br><span class="line"># 重用Date类的功能</span><br><span class="line">teacher1.birth.tell_birth()</span><br><span class="line"></span><br><span class="line"># 重用Course类的功能</span><br><span class="line">for obj in teacher1.courses:</span><br><span class="line">    obj.tell_info()</span><br><span class="line"></span><br><span class="line"># 当前生日 1987 年 3 月 23 日</span><br><span class="line"># 当前课程名字 python 当前课程周期 3mons 当前课程价格 3000.0</span><br><span class="line"># 当前课程名字 linux 当前课程周期 5mons 当前课程价格 5000.0</span><br></pre></td></tr></table></figure>

<ul>
<li>此时对象teacher1集对象独有的属性、Teacher类中的内容、Course类中的内容于一身（都可以访问到），是一个高度整合的产物</li>
<li><strong>当类之间有显著不同，并且较小的类是较大的类所需要的组件时，用组合比较好</strong></li>
</ul>
<h3 id="【6】组合和继承的区别">【6】组合和继承的区别</h3>
<ul>
<li>组合与继承都是有效地利用已有类的资源的重要方式。但是二者的概念和使用场景皆不同</li>
<li>继承的方式
<ul>
<li>通过继承建立了派生类与基类之间的关系，它是一种’是’的关系，比如白马是马，人是动物。</li>
<li>当类之间有很多相同的功能，提取这些共同的功能做成基类，用继承比较好，比如老师是人，学生是人</li>
</ul>
</li>
<li>组合的方式
<ul>
<li>用组合的方式建立了类与组合的类之间的关系，它是一种‘有’的关系,比如教授有生日，教授教python和linux课程，教授有学生s1、s2、s3…</li>
</ul>
</li>
</ul>
<h3 id="【7】小练习">【7】小练习</h3>
```python
 A没有继承B,但是A内super会基于C.mro()继续往后找
class A:
    def test(self):
        print('A---->test')
        super().aaa()


class B:
    def test(self):
        print('B---->test')

    def aaa(self):
        print('B---->aaa')


class C(A, B):
    def aaa(self):
        print('C----->aaa')


c = C()
c.test()  
# 打印结果:
'''
A---->test
B---->aaa
'''

# C作为方法调用（即c.test()）的发起者，方法调用过程中涉及的属性查找都参考C.mro()。
# 父子关系按照mro列表为准，千万不要从代码层面看父子。例如
print(C.mro())
# c.test()，发起者C.mro()列表如下
# 从列表中可以看出，B类就是A类他爹，而代码层面二者并无继承关系
# [<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>]
```


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aurora-lsk.asia/2025/10/15/5.14%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="坤">
      <meta itemprop="description" content="选择有时候比努力更重要，但是你不努力，选择就只是空谈">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="坤博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/15/5.14%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/" class="post-title-link" itemprop="url">5.14面向对象，抽象类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-10-15 11:34:55 / 修改时间：16:15:50" itemprop="dateCreated datePublished" datetime="2025-10-15T11:34:55+08:00">2025-10-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Blog/" itemprop="url" rel="index"><span itemprop="name">Blog</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>抽象类</h1>
<h2 id="【一】什么是抽象">【一】什么是抽象</h2>
<ul>
<li>将某几个具体的生物，根据特征总结一个类，逐层向上总结</li>
</ul>
```python
#唐老鸭 肉鸭 北京烤鸭 ---> 鸭子
# 北极熊 黑熊 --> 熊
# 猫 老虎 --> 猫科
# 鸭子 熊 猫科 --> 动物
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 他们的特征都是动物</span><br><span class="line"></span><br><span class="line">## 【二】什么继承</span><br><span class="line"></span><br><span class="line">- 动物--》熊--》北极熊</span><br><span class="line">- 例子</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```python</span><br><span class="line">class Animal(object):</span><br><span class="line">    def __init__(self, color, fool, hand):</span><br><span class="line">        self.color = color</span><br><span class="line">        self.fool = fool</span><br><span class="line">        self.hand = hand</span><br><span class="line"></span><br><span class="line">    def one(self):</span><br><span class="line">        print(f&quot;&#123;self.color&#125;,&#123;self.fool&#125;,&#123;self.hand&#125;&quot;)</span><br><span class="line">class Dog(Animal):</span><br><span class="line">    def __init__(self, color, fool, hand):</span><br><span class="line">        super().__init__(color, fool, hand)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dog = Dog(&quot;blank&quot;, 4, 0)</span><br><span class="line">print(dog.one)#&lt;bound method Animal.one of &lt;__main__.Dog object at 0x00000209C1A5E6B0&gt;&gt;</span><br><span class="line">print(dog.one())</span><br><span class="line">#blank,4, 0</span><br><span class="line"># None</span><br><span class="line">dog.one()#blank,4, 0</span><br></pre></td></tr></table></figure>

<h2 id="【三】抽象类">【三】抽象类</h2>
<h3 id="（1）什么是抽象类">（1）什么是抽象类</h3>
<ul>
<li>
<p>所以继承父类的子类必须重写父类的某些方法，这个父类就叫抽象类</p>
</li>
<li>
<p>与<code>java</code>一样，<code>python</code>也有抽象类的概念但是同样需要借助模块实现，抽象类是一个特殊的类，它的特殊之处在于只能被继承，不能被实例化</p>
</li>
<li>
<p>抽象类，前提是导入abc模块，在类名后的（metaclass=abc.ABCMeta）。你在自己的模块中函数头顶上定义了<code>@abc.abstractmethod</code>的时候，在子类中就要重写这个函数方法，</p>
</li>
</ul>
```python
import abc
import json


class Animal(metaclass=abc.ABCMeta):

    def __init__(self, color, foot, hand):
        self.color = color
        self.foot = foot
        self.hand = hand

    def speak(self):
        print(f'任何动物都能叫')

    # 在子类中必须重写父类的当前方法
    @abc.abstractmethod
    def walk(self):
        ...


class BlackBear(Animal):
    def __init__(self, color, foot, hand):
        super().__init__(color, foot, hand)

    # 如果不重写父类的方法就会报错
    # Can't instantiate abstract class BlackBear with abstract methods walk
    def walk(self):
        ...


bear = BlackBear('black', 2, 2)
print(bear.color)
bear.speak()

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 如果不重写父类的方法就会报错</span><br><span class="line"></span><br><span class="line">### （2）抽象类的例题</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```python</span><br><span class="line">import os</span><br><span class="line">class FileCheck(metaclass=abc.ABCMeta):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.BASE_DIR = os.path.dirname(__file__)</span><br><span class="line">        self.encoding = &#x27;utf-8&#x27;</span><br><span class="line"></span><br><span class="line">    @abc.abstractmethod</span><br><span class="line">    def read_data(self):</span><br><span class="line">        print(f&#x27;读取数据方法&#x27;)</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    @abc.abstractmethod</span><br><span class="line">    def save_data(self):</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 文本文件处理类</span><br><span class="line">class TextFileCheck(FileCheck):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.file_path = os.path.join(self.BASE_DIR, &#x27;data.text&#x27;)</span><br><span class="line"></span><br><span class="line">    def read_data(self):</span><br><span class="line">        with open(file=self.file_path, mode=&#x27;r&#x27;, encoding=self.encoding) as fp:</span><br><span class="line">            data = fp.read()</span><br><span class="line">        return data</span><br><span class="line"></span><br><span class="line">    def save_data(self):</span><br><span class="line">        with open(file=self.file_path, mode=&#x27;w&#x27;, encoding=self.encoding) as fp:</span><br><span class="line">            fp.write(&quot;你真帅！&quot;)</span><br><span class="line">        return f&quot;懵逼！&quot;</span><br><span class="line"></span><br><span class="line">obj_text = TextFileCheck()</span><br><span class="line">print(obj_text.read_data())#你真帅！</span><br><span class="line">print(obj_text.save_data())#懵逼！</span><br></pre></td></tr></table></figure>

<ul>
<li>如果父类中有函数头上有@<code>abc.abstractmethod</code>装饰器的，你在子类中不管用或者不用这个方法，你就要写重新写父类的方法，不写就会报错就会报错</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aurora-lsk.asia/2025/10/15/5.16%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%8C%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%9E%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="坤">
      <meta itemprop="description" content="选择有时候比努力更重要，但是你不努力，选择就只是空谈">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="坤博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/15/5.16%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%8C%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%9E%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">5.16面向对象，绑定方法和非绑定方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-10-15 11:34:55 / 修改时间：16:15:50" itemprop="dateCreated datePublished" datetime="2025-10-15T11:34:55+08:00">2025-10-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Blog/" itemprop="url" rel="index"><span itemprop="name">Blog</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>绑定方法和非绑定方法</h1>
<ul>
<li>我们想让类和对象都能用某一个方法</li>
</ul>
<h2 id="【一】绑定方法">【一】绑定方法</h2>
<h3 id="（1）绑定给对象的方法">（1）绑定给对象的方法</h3>
<ul>
<li>就是：对象可以任意调用的方法
<ul>
<li>对象可以直接调用 <code>obj.talk()</code></li>
<li>类调用需要传入生成的对象<code> clss.talk(obj)</code></li>
</ul>
</li>
</ul>
```python
# 对象可以任意调用的方法
class Student(object):
    def __init__(self, name):
        self.name = name

    def talk(self):
        print(f'{self.name} is talking')

# （1）对象可以直接调用绑定给对象的方法
s = Student('dream')
#执行对象的方法
s.talk() # 默认将 s 作为 self 自动传入
# （2）类调用绑定给对象的方法,需要主动传入一个生成的对象
Student.talk(s)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### （2）绑定给类的方法</span><br><span class="line"></span><br><span class="line">- 绑定给类的方法就要用`@classmethod`装饰器</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```python</span><br><span class="line"># 对象和类都可以任意调用的方法</span><br><span class="line">class Student(object):</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    # 【1】绑定给对象的方法</span><br><span class="line">    # 对象可以直接调用 obj.talk()</span><br><span class="line">    # 类调用需要传入生成的对象 clss.talk(obj)</span><br><span class="line">    def talk(self):</span><br><span class="line">        print(self)  # &lt;__main__.Student object at 0x0000017EE9CDC640&gt;</span><br><span class="line">        print(f&#x27;&#123;self.name&#125; is talking&#x27;)</span><br><span class="line"></span><br><span class="line">    # 【2】绑定给类的方法</span><br><span class="line">    @classmethod</span><br><span class="line">    def read(cls, *args, **kwargs):</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">        :return: 调用当前方法的类</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        # print(cls) # &lt;class &#x27;__main__.Student&#x27;&gt;</span><br><span class="line">        obj = cls(*args, **kwargs)  # Student(*args,**kwargs)</span><br><span class="line">        print(f&#x27;&#123;obj.name&#125; is reading&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stu = Student(&#x27;dream&#x27;)</span><br><span class="line"># print(Student) # &lt;class &#x27;__main__.Student&#x27;&gt;</span><br><span class="line"># （1）对象调用绑定给类的方法, 默认将实例化得到当前对象的类自动传入</span><br><span class="line">stu.read(&#x27;dream&#x27;)#dream is reading</span><br><span class="line"># （2）类调用绑定给类的方法,类可以直接调用，默认将调用当前方法的类自动传入</span><br><span class="line">Student.read(&#x27;dream&#x27;)#dream is reading</span><br></pre></td></tr></table></figure>

<h3 id="3-非绑定方法">(3)非绑定方法</h3>
<ul>
<li>关键装饰器<code>@staticmethod</code>
<ul>
<li>对象调用非绑定方法，直接调用
<ul>
<li><code>Student.write()</code></li>
</ul>
</li>
<li>类调用非绑定方法，直接调用
<ul>
<li><code>Student.write()</code></li>
</ul>
</li>
</ul>
</li>
<li>不与类或对象绑定，类和对象都可以调用，但是没有自动传值那么一说。</li>
<li>就是一个普通工具而已</li>
</ul>
```python
class Student(object):
    def __init__(self, name):
        self.name = name
        ...

    @staticmethod
    #不能自动传值
    def write():
        print(f"00")


student = Student("tom")
print(Student)#<class '__main__.Student'>
# （1）对象调用非绑定方法, 不用传任何参数，和普通函数一样
student.write()
# （2）类调用非绑定方法, 不用传任何参数，和普通函数一样
Student.write()
```

<h2 id="【二】两个绑定方法的总结">【二】两个绑定方法的总结</h2>
<h3 id="（1）绑定方法">（1）绑定方法</h3>
<h4 id="【1】绑定给对象的方法">【1】绑定给对象的方法</h4>
<ul>
<li>我们正常在函数内部定义的方法</li>
<li>特征就是自动补全self</li>
<li>对象调用直接调用(默认将当前的对象作为self默认参数传入)
<ul>
<li><code>实例化得到的对象.函数名()</code></li>
</ul>
</li>
<li>类调用需要传递额外的参数，额外的参数就是实例化得到的对象
<ul>
<li><code>类名.函数名（实例化得到的对象）</code></li>
</ul>
</li>
</ul>
<h4 id="【2】绑定给类的方法">【2】绑定给类的方法</h4>
<ul>
<li>需要在类内部用 <code>@classmethod </code>装饰的函数</li>
<li>特征就是自动补全<code>cls</code> 并且有<code>@classmethod</code>装饰</li>
<li>对象调用直接调用(默认将当前的对象的类作为<code>cls</code>默认参数传入)
<ul>
<li><code>实例化得到的对象.函数名()</code></li>
</ul>
</li>
<li>类调用直接调用，默认将当前类作为<code>cls</code>自动传入
<ul>
<li><code>类名.函数名（）</code></li>
</ul>
</li>
</ul>
<h3 id="2-非绑定方法">(2)非绑定方法</h3>
<ul>
<li>需要在类内部用 <code>@staticmethod</code> 装饰的函数</li>
<li>特征不会自动补全任何参数</li>
<li>对象调用直接调用</li>
<li>类调用直接调用
<ul>
<li>类调用直接调用</li>
</ul>
</li>
<li>就像一个普通函数
<ul>
<li><code>类名.函数名（）</code></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aurora-lsk.asia/2025/10/15/5.15%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%A4%9A%E6%80%81%E5%92%8C%E5%A4%9A%E6%80%81%E6%80%A7%EF%BC%8C%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="坤">
      <meta itemprop="description" content="选择有时候比努力更重要，但是你不努力，选择就只是空谈">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="坤博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/15/5.15%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%A4%9A%E6%80%81%E5%92%8C%E5%A4%9A%E6%80%81%E6%80%A7%EF%BC%8C%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">5.15面向对象，多态和多态性，鸭子类型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-10-15 11:34:55 / 修改时间：16:15:50" itemprop="dateCreated datePublished" datetime="2025-10-15T11:34:55+08:00">2025-10-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Blog/" itemprop="url" rel="index"><span itemprop="name">Blog</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>多态和多态性，鸭子类型</h1>
<ul>
<li>多态是面向对象的特性之一</li>
</ul>
<h2 id="【一】什么是多态">【一】什么是多态</h2>
<ul>
<li>
<p>多态是指一个事物的多种形态</p>
</li>
<li>
<p>例子:动物有多种形态—》猫，狗，猪…</p>
</li>
</ul>
```python
#导入模块
import abc

#  总的类动物类
class Animal(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def talk(self):
        ...


# 具体的类 猫类
class Cat(Animal):
    def talk(self):
        print(f"喵喵喵 ~~~ ")


# 具体的类 狗类
class Dog(Animal):
    def talk(self):
        print(f"汪汪汪")
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- @`abc.abstractmethod`必须重写下面这个方法</span><br><span class="line"></span><br><span class="line">## 【二】多态性</span><br><span class="line"></span><br><span class="line">- 指事物的多种形态的性质</span><br><span class="line"></span><br><span class="line">### （1）静态多态性</span><br><span class="line"></span><br><span class="line">- 运算符+表达式</span><br><span class="line"></span><br><span class="line">### （2）动态多态性</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```python</span><br><span class="line">import abc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 总的类动物类</span><br><span class="line">class Animal(metaclass=abc.ABCMeta):</span><br><span class="line">    @abc.abstractmethod</span><br><span class="line">    def talk(self):</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 具体的类 猫类</span><br><span class="line">class Cat(Animal):</span><br><span class="line">    def talk(self):</span><br><span class="line">        print(f&quot;喵喵喵 ~~~ &quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 具体的类 狗类</span><br><span class="line">class Dog(Animal):</span><br><span class="line">    def talk(self):</span><br><span class="line">        print(f&quot;汪汪汪&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class People(Animal):</span><br><span class="line">    def talk(self):</span><br><span class="line">        print(f&quot;人会说话!&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#多态性的方法</span><br><span class="line">def talk(obj):</span><br><span class="line">    obj.talk()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#实例化对象</span><br><span class="line">people = People()</span><br><span class="line">cat = Cat()</span><br><span class="line"></span><br><span class="line">talk(people)</span><br><span class="line">talk(cat)</span><br></pre></td></tr></table></figure>

<h2 id="【三】为什么要学习多态性">【三】为什么要学习多态性</h2>
<ul>
<li>增强代码的可读性和扩展性</li>
</ul>
<h1>鸭子类型</h1>
<h2 id="【一】什么是鸭子类型">【一】什么是鸭子类型</h2>
<ul>
<li>长得像鸭子，走起来像鸭子，叫起来像鸭子，你就是鸭子！</li>
<li>在每一个语言中都有这这个概念，是一种语言风格</li>
</ul>
<h3 id="（1）在java里面">（1）在java里面</h3>
<ul>
<li>定义接口，并且继承后的接口必须重写</li>
</ul>
<h3 id="（2）在python里面">（2）在python里面</h3>
<ul>
<li>强制重新写父类的方法用：抽象类</li>
</ul>
```python
class Cat():
    def talk(self):
        print(f"可以叫")

    def swim(self):
        print(f'可以游泳')


class Duck():
    def talk(self):
        print(f"可以叫")

    def swim(self):
        print(f'可以游泳')
```

<ul>
<li>那么我们就可以说这只猫就是一只鸭子</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aurora-lsk.asia/2025/10/15/5.19%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%85%83%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="坤">
      <meta itemprop="description" content="选择有时候比努力更重要，但是你不努力，选择就只是空谈">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="坤博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/10/15/5.19%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%85%83%E7%B1%BB/" class="post-title-link" itemprop="url">5.19面向对象，元类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-10-15 11:34:55 / 修改时间：16:15:50" itemprop="dateCreated datePublished" datetime="2025-10-15T11:34:55+08:00">2025-10-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Blog/" itemprop="url" rel="index"><span itemprop="name">Blog</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>元类</h1>
<h2 id="【一】-call-方法">【一】<code>__call__</code>方法</h2>
<ul>
<li><code>__call__</code>方法：会在触发当前类（）或对象（）调用的时候触发</li>
<li><code>__call__</code>方法触发 的条件是
<ul>
<li>调用：类（）会触发</li>
<li>调用：对象（）会触发</li>
</ul>
</li>
</ul>
```python
class Student(type):
    def __init__(self, name, bases, namespace):
        print("元类的init")
        super().__init__(name, bases,namespace)

    def __call__(cls, *arg, **keyword):
        print(cls)#<class '__main__.Person'>
        print("元类的__call__")
        obj = super().__call__(*arg, **keyword)
        return obj

class Person(metaclass=Student):
    def __init__(self):
        self.name = 'dream'
        print("__init__")

    def __call__(self):
        print("__call__")


#类名加括号的时候会触发元类的__init__再触发元类里面的__call__(__call__必须返回一个对象)，再触发子类的__init__
person = Person()
输出：#元类的init
    #<class '__main__.Person'>
    # 元类的__call__
    # __init__

#元类的__call__必须返回一个对象，不然不可调用
person()
输出：#__call__
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 方法`callable(对象/类名)`：检测当前对象是否可被调用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```python</span><br><span class="line">class Person(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.name = &#x27;dream&#x27;</span><br><span class="line">        print(&quot;__init__&quot;)</span><br><span class="line">    def __call__(self):</span><br><span class="line">        print(&quot;__call__&quot;)</span><br><span class="line"></span><br><span class="line">#得到实例化对象的过程就已经触发了__init__方法</span><br><span class="line">person = Person()#__init__</span><br><span class="line">print(callable(person))#True</span><br><span class="line">print(callable(Person))#True</span><br></pre></td></tr></table></figure>

<h2 id="【二】什么是元类">【二】什么是元类</h2>
<ul>
<li>元类是所有类的基类，包括object</li>
</ul>
<h3 id="1-元类的创建方式">(1)元类的创建方式</h3>
<ul>
<li>
<p>创建元类的方法</p>
<ul>
<li>
<p>使用<code>type</code>生成</p>
<ul>
<li>
<p>类名 = type（“类名”，（父类1，父类2…）,名称空间字典）</p>
```python
      Student = type('Student', (object,), {'name': "dream"})
      <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  - `MyClass`继承了`MyType`元类的类</span><br><span class="line"></span><br><span class="line">    - `metaclass` 指定元类</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```python</span><br><span class="line">class MyType(type):</span><br><span class="line">    ....</span><br><span class="line">    </span><br><span class="line">class MyClass(metaclass=MyType):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
<li>
<p>如果是类的名称空间字典，一定会看到除了自己定义的属性以外很对属性（不用管都是自带的属性）</p>
</li>
<li>
<p>如果是对象的名称空间，一定只会看到<code>__init__</code>的初始化的属性</p>
</li>
</ul>
<h3 id="（2）元类的使用">（2）元类的使用</h3>
<ul>
<li>学习元类</li>
<li>你可以随意的往里面添加东西</li>
<li>我们可以在元类创键类的过程中进行修改和增加</li>
</ul>
<h4 id="【1】元类的基础使用">【1】元类的基础使用</h4>
<ul>
<li>创建一个 元类</li>
</ul>
```python
class Person(type):
    def __init__(cls, class_name, class_bases, class_name_space):
        # class是当前类的本身
        print(f"{cls}")  # <class '__main__.Student'>
        
        # class_name是当前类的名字
        print(f"{class_name}")  # Student
        
        # class_bases是当前类的父类
        print(f"{class_bases}")  # ()
        
        # class_name_space是当前类的名称空间
        print(f"{class_name_space}")  # {'__module__': '__main__', '__qualname__': 'Student'}
        
        #为了保证类能够正常运行
        super().__init__(class_name, class_bases, class_name_space)


#创建一个继承元类的类
# metaclass 指定元类
class Student(metaclass=Person):
    ...
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### (3)控制类名首字母必须大写</span><br><span class="line"></span><br><span class="line">- 控制当前类名首字母必须大写，不大写就会报错</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```python</span><br><span class="line">#创建一个元类</span><br><span class="line">classclass Person(type):</span><br><span class="line">    def __init__(cls, class_name, class_bases, class_name_space):</span><br><span class="line">        # class_name是当前类的名字</span><br><span class="line">        print(f&quot;&#123;class_name&#125;&quot;)  # Student</span><br><span class="line">        if not class_name.istitle():</span><br><span class="line">            raise TypeError(f&quot;&#123;class_name&#125;首字母必须大写!&quot;)</span><br><span class="line">        super().__init__(class_name, class_bases, class_name_space)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#继承元类的类</span><br><span class="line">class student(metaclass=Person):</span><br><span class="line">    ...</span><br><span class="line">#主动抛出异常</span><br><span class="line">#继承元类的类首字母不大写就会报错，有几个类的首字母不是大写的就会报错</span><br><span class="line">输出：#TypeError: student首字母必须大写!</span><br></pre></td></tr></table></figure>

<h3 id="【4】-call-补充">【4】<code>__call__</code>补充</h3>
<ul>
<li>类（）触发的是元类中的<code>__call__</code></li>
<li>对象（）触发的是父类中的<code>__call__</code></li>
</ul>
```python
class MyType(type):
    def __init__(cls, class_name, class_bases, class_name_space):
        print(f"MyType 的 __init__ 被触发")
        super().__init__(class_name, class_bases, class_name_space)

    # 【三】触发元类中的 __call__ 方法
    def __call__(self, *args, **kwargs):
        # 【四】打印三个参数
        # 【1】当前类本身
        print(f"self :>>>> {self}")  # self :>>>> <class '__main__.MyClass'>
        # 【2】类实例化时候传进来的位置参数
        print(f"args :>>>> {args}")  # args :>>>> ('dream',)
        # 【3】类实例化时候传进来的关键字参数
        print(f"kwargs :>>>> {kwargs}")  # kwargs :>>>> {'age': 18}
        print(f'类名() 触发 MyType 中的 __call__')
        # 【五】如果不写返回值，返回的值默认是就是None
        # 一定要返回一个对象 ---> 自己不会写
        # 自己不知道怎么写但是，以前我不写都能拿到对象 ---> 有人帮你写好了并且是 type 帮你写好了
        # 直接把 type 的拿过来用  super().__call__()
        # 正常返回当前类的对象
        # super() 其实是 type
        obj = super().__call__(*args, **kwargs)
        print(f"obj :>>>> {obj}")  # obj :>>>> <__main__.MyClass object at 0x000002A89A56C4C0>
        # 【六】直接将当前返回的对象返回
        return obj


# 【一】触发 MyType 的 __init__ 方法
class MyClass(metaclass=MyType):
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __call__(self, *args, **kwargs):
        print(f'当前 MyClass 的 对象() 触发了 __call__')


# 【二】MyClass('dream', age=18)类(参数) ---> 触发 MyType 的 __call__ 方法
# 【七】me 接收到的就是 元类：MyType 的 __call__ 方法 返回的 obj 对象
me = MyClass('dream', age=18)
print(me())
输出：#当前 MyClass 的 对象() 触发了 __call__
# None#因为没有返回值
print(me.name)
输出：#dream
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 再用调用`对象（）`之前，元类里面的`__call__`方法必须返回一个对象obj，如果不返回就会报错</span><br><span class="line">  - 因为（me 接收到的就是 `MyType `的` __call__` 方法 返回的 obj 对象）</span><br><span class="line"></span><br><span class="line">- **重点**：类(参数) ---&gt; 触发 的是元类里 的` __call__ `方法</span><br><span class="line">  - 对象()调用的是类里面的`__call__`方法</span><br><span class="line"></span><br><span class="line">### （5）控制类必须通过关键字传参</span><br><span class="line"></span><br><span class="line">- </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```python</span><br><span class="line">class MyType(type):</span><br><span class="line">    def __init__(cls, class_name, class_bases, class_name_space):</span><br><span class="line">        print(f&quot;MyType 的 __init__ 被触发&quot;)</span><br><span class="line">        super().__init__(class_name, class_bases, class_name_space)</span><br><span class="line"></span><br><span class="line">    def __call__(self, *args, **kwargs):</span><br><span class="line">        print(f&quot;args :&gt;&gt;&gt;&gt; &#123;args&#125;&quot;)  # args :&gt;&gt;&gt;&gt; (&#x27;tom&#x27;,)</span><br><span class="line">        if args:</span><br><span class="line">            raise TypeError(&quot;必须通过关键字传参！&quot;)</span><br><span class="line">        print(f&quot;kwargs :&gt;&gt;&gt;&gt; &#123;kwargs&#125;&quot;)  # kwargs :&gt;&gt;&gt;&gt; &#123;&#x27;age&#x27;: 18&#125;</span><br><span class="line">        obj = super().__call__(*args, **kwargs)</span><br><span class="line">        return obj</span><br><span class="line"></span><br><span class="line">class MyClass(metaclass=MyType):</span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    def __call__(self, *args, **kwargs):</span><br><span class="line">        print(f&#x27;当前 MyClass 的 对象() 触发了 __call__&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#传的全是关键字参数，不会报错</span><br><span class="line">me = MyClass( name=&quot;tom&quot;,age=18)</span><br><span class="line"># 输出：</span><br><span class="line"># MyType 的 __init__ 被触发</span><br><span class="line"># args :&gt;&gt;&gt;&gt; ()</span><br><span class="line"># kwargs :&gt;&gt;&gt;&gt; &#123;&#x27;name&#x27;: &#x27;tom&#x27;, &#x27;age&#x27;: 18&#125;</span><br><span class="line"></span><br><span class="line">#不全是关键字传参就会报错，主动抛出异常</span><br><span class="line">me = MyClass( name=&quot;tom&quot;,age=18)</span><br><span class="line">#输出：</span><br><span class="line"># MyType 的 __init__ 被触发</span><br><span class="line"># args :&gt;&gt;&gt;&gt; (&#x27;tom&#x27;,)</span><br><span class="line"># TypeError: 必须通过关键字传参！#报错信息</span><br></pre></td></tr></table></figure>

<h3 id="【6】总结">【6】总结</h3>
<h4 id="（1）高度定制类的产生过程">（1）高度定制类的产生过程</h4>
<ul>
<li>
<p>在元类的<code>__init__</code>方法里面可以定制-类名，父类，名称空间</p>
</li>
<li>
<p>意思就是要求格式问题。比如类的首字母必须大写</p>
<ul>
<li>案例：要是继承元类的类的首字母不大写就会主动抛出异常（前提是你要设置主动方抛出异常语法）</li>
<li>这些都是在元类里面的<code>__init__</code>里面实行的</li>
</ul>
</li>
</ul>
<h4 id="（2）高度定制对象的产生过程">（2）高度定制对象的产生过程</h4>
<ul>
<li>
<p>意思就是：</p>
<ul>
<li>在没有得到对象之前对对象的属性进行操作</li>
</ul>
</li>
<li>
<p>在元类里面的<code>__call__</code>方法里面可以定制–传参的格式，比如要求必须<strong>位置参数传参</strong>，或者强制要求必须<strong>关键字传参</strong></p>
</li>
</ul>
<h2 id="【三】元类结合-new">【三】元类结合<code>__new__</code></h2>
<ul>
<li><code>__new__</code>和<code>__init__</code>两个方法搭配着用</li>
</ul>
<h3 id="（1）类中的-new">（1）类中的<code>__new__</code>:</h3>
```python
class MyClass(object):
    def __init__(self, name, age):
        print(f"给当前 MyClass 类的对象初始化属性的时候会触发 __init__")
        self.name = name
        self.age = age

    def __call__(self, *args, **kwargs):
        print(f"当前 MyClass 类的对象被调用的时候会触发 __call__")
        return f'当前 MyClass 类 的 __call__ 的返回值 :>>>> {self.name}'

    # 花骨架 有了骨架才能上色
    def __new__(cls, *args, **kwargs):
        print(f"给当前 MyClass 类的对象创建骨架的时候会触发 __new__")

        # 当前类本身
        print(f" MyClass 类 的 __call__ 的 cls :>>>> {cls}")
        # MyClass 类 的 __call__ 的 cls :>>>> <class '__main__.MyClass'>

        # 当前类初始化传的位置参数
        print(f" MyClass 类 的 __call__ 的 args :>>>> {args}")
        # MyClass 类 的 __call__ 的 args :>>>> ('tom',18)

        # 当前类初始化传的关键字参数
        print(f" MyClass 类 的 __call__ 的 kwargs :>>>> {kwargs}")
        # MyClass 类 的 __call__ 的 kwargs :>>>> {}

        # 调用父类 的 object 的 __new__ 帮我搭建好骨架
        obj = object.__new__(cls)  # my = MyClass()
        # 查看当前返回值发现是一个对象
        print(f'obj :>>>> {obj}')
        # obj :>>>> <__main__.MyClass object at 0x000001984B032340>
        # 发现当前对象的民称空间是空的
        print(f'obj.__dict__ :>>>> {obj.__dict__}')
        # obj.__dict__ :>>>> {}
        # 调用自己的 __init__ 方法 初始化属性
        obj.__init__(*args, **kwargs)
        # 给自己的名称空间初始化属性
        print(f'obj.__dict__ :>>>> {obj.__dict__}')
        # obj.__dict__ :>>>> {'name': 'dream', 'age': 18}
        return obj


my = MyClass("tom", 18)
# 输出：#给当前 MyClass 类的对象创建骨架的时候会触发 __new__
#  MyClass 类 的 __call__ 的 cls :>>>> <class '__main__.MyClass'>
#  MyClass 类 的 __call__ 的 args :>>>> ('tom', 18)
#  MyClass 类 的 __call__ 的 kwargs :>>>> {}
# obj :>>>> <__main__.MyClass object at 0x000001A5EBE17EE0>
# obj.__dict__ :>>>> {}
# 给当前 MyClass 类的对象初始化属性的时候会触发 __init__
# obj.__dict__ :>>>> {'name': 'tom', 'age': 18}
# 给当前 MyClass 类的对象初始化属性的时候会触发 __init__
my()
# 输出：当前 MyClass 类的对象被调用的时候会触发 __call__
完成对象属性的初始化
print(f"{my.name}")
#tom
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&#123;% endraw %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 类() 调用 </span><br><span class="line">  - 一定会触发` __init__ `初始化对象的属性</span><br><span class="line">    -  `__init__ ` 给你人体骨架上个色</span><br><span class="line">  - 在调用`  __init__  `之前要调用` __new__  `</span><br><span class="line">    - ` __new__ `相当于将你人体的骨架搭建好</span><br><span class="line"></span><br><span class="line">### （2）元类中的`__new__`</span><br><span class="line"></span><br><span class="line">- </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% raw %&#125;```python</span><br><span class="line">class MyType(type):</span><br><span class="line">    def __new__(cls, *args, **kwargs):</span><br><span class="line">        # 当前类本身</span><br><span class="line">        print(cls)#&lt;class &#x27;__main__.MyType&#x27;&gt;</span><br><span class="line">        # 当前类初始化传的位置参数</span><br><span class="line">        print(args)#(&#x27;MyClass&#x27;, (), &#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;__qualname__&#x27;: &#x27;MyClass&#x27;, &#x27;__init__&#x27;: &lt;function MyClass.__init__ at 0x0000014467309CF0&gt;, &#x27;__call__&#x27;: &lt;function MyClass.__call__ at 0x0000014467309D80&gt;&#125;)</span><br><span class="line">        # 当前类初始化传的关键字参数</span><br><span class="line">        print(kwargs)#&#123;&#125;</span><br><span class="line">        # 让父类帮忙构建骨架</span><br><span class="line">        obj = type.__new__(cls,*args, **kwargs)</span><br><span class="line">        print(obj)#&lt;class &#x27;__main__.MyClass&#x27;&gt;</span><br><span class="line">        print(obj.__dict__)#&#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;__init__&#x27;: &lt;function MyClass.__init__ at 0x0000014467309CF0&gt;, &#x27;__call__&#x27;: &lt;function MyClass.__call__ at 0x0000014467309D80&gt;, &#x27;__dict__&#x27;: &lt;attribute &#x27;__dict__&#x27; of &#x27;MyClass&#x27; objects&gt;, &#x27;__weakref__&#x27;: &lt;attribute &#x27;__weakref__&#x27; of &#x27;MyClass&#x27; objects&gt;, &#x27;__doc__&#x27;: None&#125;</span><br><span class="line">        return obj</span><br><span class="line">	</span><br><span class="line">    #</span><br><span class="line">    def __init__(cls, class_name, class_bases, class_name_space):</span><br><span class="line">        super().__init__(class_name, class_bases, class_name_space)</span><br><span class="line">	</span><br><span class="line">    #调用类名（）试行</span><br><span class="line">    def __call__(cls, *args, **kwargs):</span><br><span class="line">        print(f&quot;MyType.args&#123;args&#125;&quot;)#MyType.args()</span><br><span class="line">        print(f&quot;MyType.kwargs&#123;kwargs&#125;&quot;)#MyType.kwargs&#123;&#x27;name&#x27;: &#x27;tom&#x27;&#125;</span><br><span class="line">        obj = super().__call__(*args, **kwargs)</span><br><span class="line">        return obj</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MyClass(metaclass=MyType):</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    def __call__(self, *args, **kwargs):</span><br><span class="line">        print(&quot;MyClass&gt;&gt;&gt;&gt;__call__&quot;)</span><br><span class="line">        return f&quot;当前 MyClass 类 的 __call__ 的返回值 :&gt;&gt;&gt;&gt; &#123;self.name&#125;&quot;</span><br><span class="line"></span><br><span class="line">my = MyClass(name=&quot;tom&quot;)</span><br><span class="line">输出：#&lt;class &#x27;__main__.MyType&#x27;&gt;</span><br><span class="line"># (&#x27;MyClass&#x27;, (), &#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;__qualname__&#x27;: &#x27;MyClass&#x27;, &#x27;__init__&#x27;: &lt;function MyClass.__init__ at 0x0000026782249CF0&gt;, &#x27;__call__&#x27;: &lt;function MyClass.__call__ at 0x0000026782249D80&gt;&#125;)</span><br><span class="line"># &#123;&#125;</span><br><span class="line"># &lt;class &#x27;__main__.MyClass&#x27;&gt;</span><br><span class="line"># &#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;__init__&#x27;: &lt;function MyClass.__init__ at 0x0000026782249CF0&gt;, &#x27;__call__&#x27;: &lt;function MyClass.__call__ at 0x0000026782249D80&gt;, &#x27;__dict__&#x27;: &lt;attribute &#x27;__dict__&#x27; of &#x27;MyClass&#x27; objects&gt;, &#x27;__weakref__&#x27;: &lt;attribute &#x27;__weakref__&#x27; of &#x27;MyClass&#x27; objects&gt;, &#x27;__doc__&#x27;: None&#125;</span><br><span class="line"># MyType.args()</span><br><span class="line"># MyType.kwargs&#123;&#x27;name&#x27;: &#x27;tom&#x27;&#125;</span><br><span class="line"></span><br><span class="line">my()</span><br><span class="line">输出：#MyClass&gt;&gt;&gt;&gt;__call__</span><br><span class="line"></span><br><span class="line">MyClass(&quot;tom&quot;)</span><br><span class="line">输出：#MyType.args(&#x27;tom&#x27;,)</span><br><span class="line"># MyType.kwargs&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>类() 调用
<ul>
<li>一定会触发<code>__init__</code>初始化对象的属性
<ul>
<li><code>__init__ </code> 给你人体骨架上个色</li>
</ul>
</li>
<li>在调用<code> __init__ </code>之前要调用<code>__new__ </code>
<ul>
<li><code>__new__</code>相当于将你人体的骨架搭建好</li>
</ul>
</li>
</ul>
</li>
<li>先试行<code>__new__</code>在试行<code>__init__</code></li>
<li>调用类名（参数）的时候试行 元类里面的<code>__call__</code></li>
<li>调用对象（）的时候试行类里面的<code>__call__</code></li>
</ul>
<h3 id="（3）总结">（3）总结</h3>
<ul>
<li>
<p><code>__new__</code>是一个静态方法，它负责创建并返回一个新对象。当你调用一个类（如<code>A()</code>）时，<code>__new__</code>方法首先被调用，用于创建实例。</p>
</li>
<li>
<p>元类的<code>__new__</code>方法用于创建类对象。</p>
</li>
<li>
<p>类的<code>__new__</code>方法用于<strong>实例化对象</strong>。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">坤</p>
  <div class="site-description" itemprop="description">选择有时候比努力更重要，但是你不努力，选择就只是空谈</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">194</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">坤</span>
</div>
  <div class="powered-by">由 <a href="https://github.com/lsk-0912" class="theme-link" rel="noopener" target="_blank">lsk-0912</a> & <a href="https://github.com/lsk-0912" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
